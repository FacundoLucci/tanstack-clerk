{
  "version": 3,
  "sources": ["../../../../.pnpm/@tanstack+start@1.82.6_@types+node@22.9.3_ioredis@5.4.1_react-dom@18.3.1_react@18.3.1__react@_kv752pvnv3eiglj5qrf6f4j7n4/node_modules/@tanstack/start/src/client/Asset.tsx", "../../../../.pnpm/@tanstack+start@1.82.6_@types+node@22.9.3_ioredis@5.4.1_react-dom@18.3.1_react@18.3.1__react@_kv752pvnv3eiglj5qrf6f4j7n4/node_modules/@tanstack/start/src/client/headers.ts", "../../../../.pnpm/@tanstack+start@1.82.6_@types+node@22.9.3_ioredis@5.4.1_react-dom@18.3.1_react@18.3.1__react@_kv752pvnv3eiglj5qrf6f4j7n4/node_modules/@tanstack/start/src/client/createServerFn.ts", "../../../../.pnpm/@tanstack+start@1.82.6_@types+node@22.9.3_ioredis@5.4.1_react-dom@18.3.1_react@18.3.1__react@_kv752pvnv3eiglj5qrf6f4j7n4/node_modules/@tanstack/start/src/client/createMiddleware.ts", "../../../../.pnpm/@tanstack+start@1.82.6_@types+node@22.9.3_ioredis@5.4.1_react-dom@18.3.1_react@18.3.1__react@_kv752pvnv3eiglj5qrf6f4j7n4/node_modules/@tanstack/start/src/client/serverOnly.ts", "../../../../.pnpm/@tanstack+start@1.82.6_@types+node@22.9.3_ioredis@5.4.1_react-dom@18.3.1_react@18.3.1__react@_kv752pvnv3eiglj5qrf6f4j7n4/node_modules/@tanstack/start/src/client/DehydrateRouter.tsx", "../../../../.pnpm/@tanstack+start@1.82.6_@types+node@22.9.3_ioredis@5.4.1_react-dom@18.3.1_react@18.3.1__react@_kv752pvnv3eiglj5qrf6f4j7n4/node_modules/@tanstack/start/src/client/json.ts", "../../../../.pnpm/@tanstack+react-cross-context@1.81.9_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@tanstack/react-cross-context/src/Context.ts", "../../../../.pnpm/@tanstack+start@1.82.6_@types+node@22.9.3_ioredis@5.4.1_react-dom@18.3.1_react@18.3.1__react@_kv752pvnv3eiglj5qrf6f4j7n4/node_modules/@tanstack/start/src/client/Meta.tsx", "../../../../.pnpm/@tanstack+start@1.82.6_@types+node@22.9.3_ioredis@5.4.1_react-dom@18.3.1_react@18.3.1__react@_kv752pvnv3eiglj5qrf6f4j7n4/node_modules/@tanstack/start/src/client/Scripts.tsx", "../../../../.pnpm/@tanstack+start@1.82.6_@types+node@22.9.3_ioredis@5.4.1_react-dom@18.3.1_react@18.3.1__react@_kv752pvnv3eiglj5qrf6f4j7n4/node_modules/@tanstack/start/src/client/serialization.tsx", "../../../../.pnpm/@tanstack+start@1.82.6_@types+node@22.9.3_ioredis@5.4.1_react-dom@18.3.1_react@18.3.1__react@_kv752pvnv3eiglj5qrf6f4j7n4/node_modules/@tanstack/start/src/client/StartClient.tsx", "../../../../.pnpm/@tanstack+start@1.82.6_@types+node@22.9.3_ioredis@5.4.1_react-dom@18.3.1_react@18.3.1__react@_kv752pvnv3eiglj5qrf6f4j7n4/node_modules/@tanstack/start/src/client/renderRSC.tsx", "../../../../.pnpm/@tanstack+start@1.82.6_@types+node@22.9.3_ioredis@5.4.1_react-dom@18.3.1_react@18.3.1__react@_kv752pvnv3eiglj5qrf6f4j7n4/node_modules/@tanstack/start/src/client/useServerFn.ts"],
  "sourcesContent": ["/* eslint-disable @eslint-react/dom/no-dangerously-set-innerhtml */\nimport type { RouterManagedTag } from '@tanstack/react-router'\n\nexport function Asset({ tag, attrs, children }: RouterManagedTag): any {\n  switch (tag) {\n    case 'title':\n      return (\n        <title {...attrs} suppressHydrationWarning>\n          {children}\n        </title>\n      )\n    case 'meta':\n      return <meta {...attrs} suppressHydrationWarning />\n    case 'link':\n      return <link {...attrs} suppressHydrationWarning />\n    case 'style':\n      return (\n        <style\n          {...attrs}\n          dangerouslySetInnerHTML={{ __html: children as any }}\n        />\n      )\n    case 'script':\n      if ((attrs as any) && (attrs as any).src) {\n        return <script {...attrs} suppressHydrationWarning />\n      }\n      if (typeof children === 'string')\n        return (\n          <script\n            {...attrs}\n            dangerouslySetInnerHTML={{\n              __html: children,\n            }}\n            suppressHydrationWarning\n          />\n        )\n      return null\n    default:\n      return null\n  }\n}\n", "import type { OutgoingHttpHeaders } from 'node:http2'\n\n// A utility function to turn HeadersInit into an object\nexport function headersInitToObject(\n  headers: HeadersInit,\n): Record<keyof OutgoingHttpHeaders, string> {\n  const obj: Record<keyof OutgoingHttpHeaders, string> = {}\n  const headersInstance = new Headers(headers)\n  for (const [key, value] of headersInstance.entries()) {\n    obj[key] = value\n  }\n  return obj\n}\n\ntype AnyHeaders =\n  | Headers\n  | HeadersInit\n  | Record<string, string>\n  | Array<[string, string]>\n  | OutgoingHttpHeaders\n  | undefined\n\n// Helper function to convert various HeaderInit types to a Headers instance\nfunction toHeadersInstance(init: AnyHeaders) {\n  if (init instanceof Headers) {\n    return new Headers(init)\n  } else if (Array.isArray(init)) {\n    return new Headers(init)\n  } else if (typeof init === 'object') {\n    return new Headers(init as HeadersInit)\n  } else {\n    return new Headers()\n  }\n}\n\n// Function to merge headers with proper overrides\nexport function mergeHeaders(...headers: Array<AnyHeaders>) {\n  return headers.reduce((acc: Headers, header) => {\n    const headersInstance = toHeadersInstance(header)\n    for (const [key, value] of headersInstance.entries()) {\n      acc.set(key, value)\n    }\n    return acc\n  }, new Headers())\n}\n", "import invariant from 'tiny-invariant'\nimport { defaultTransformer } from '@tanstack/react-router'\nimport { mergeHeaders } from './headers'\nimport type {\n  AnyValidator,\n  Constrain,\n  DefaultTransformerParse,\n  DefaultTransformerStringify,\n  ResolveValidatorInput,\n  Validator,\n} from '@tanstack/react-router'\nimport type {\n  AnyMiddleware,\n  MergeAllServerContext,\n  MergeAllValidatorInputs,\n  MergeAllValidatorOutputs,\n  ResolveAllValidators,\n} from './createMiddleware'\n\n//\n\nexport interface JsonResponse<TData> extends Response {\n  json: () => Promise<TData>\n}\n\nexport type CompiledFetcherFnOptions = {\n  method: Method\n  data: unknown\n  headers?: HeadersInit\n}\n\nexport type Fetcher<TMiddlewares, TValidator, TResponse> = {\n  url: string\n  __executeServer: (opts: {\n    method: Method\n    data: unknown\n    headers?: HeadersInit\n  }) => Promise<unknown>\n} & FetcherImpl<TMiddlewares, TValidator, TResponse>\n\nexport type IsDataOptional<TMiddlewares, TValidator> = ResolveAllValidators<\n  TMiddlewares,\n  TValidator\n>\n\nexport type FetcherImpl<TMiddlewares, TValidator, TResponse> =\n  undefined extends MergeAllValidatorInputs<TMiddlewares, TValidator>\n    ? (\n        opts?: OptionalFetcherDataOptions<\n          MergeAllValidatorInputs<TMiddlewares, TValidator>\n        >,\n      ) => Promise<FetcherData<TResponse>>\n    : (\n        opts: RequiredFetcherDataOptions<\n          MergeAllValidatorInputs<TMiddlewares, TValidator>\n        >,\n      ) => Promise<FetcherData<TResponse>>\n\nexport type FetcherBaseOptions = {\n  headers?: HeadersInit\n}\n\nexport interface RequiredFetcherDataOptions<TInput> extends FetcherBaseOptions {\n  data: TInput\n}\n\nexport interface OptionalFetcherDataOptions<TInput> extends FetcherBaseOptions {\n  data?: TInput\n}\n\nexport type FetcherData<TResponse> = DefaultTransformerParse<\n  TResponse extends JsonResponse<infer TData> ? TData : TResponse\n>\n\nexport type RscStream<T> = {\n  __cacheState: T\n}\n\nexport type Method = 'GET' | 'POST'\n\nexport type ServerFn<TMethod, TMiddlewares, TValidator, TResponse> = (\n  ctx: ServerFnCtx<TMethod, TMiddlewares, TValidator>,\n) =>\n  | Promise<DefaultTransformerStringify<TResponse>>\n  | DefaultTransformerStringify<TResponse>\n\nexport type ServerFnCtx<TMethod, TMiddlewares, TValidator> = {\n  method: TMethod\n  data: MergeAllValidatorOutputs<TMiddlewares, TValidator>\n  context: MergeAllServerContext<TMiddlewares>\n}\n\nexport type CompiledFetcherFn<TResponse> = {\n  (opts: CompiledFetcherFnOptions & ServerFnBaseOptions): Promise<TResponse>\n  url: string\n}\n\ntype ServerFnBaseOptions<\n  TMethod extends Method = 'GET',\n  TResponse = unknown,\n  TMiddlewares = unknown,\n  TInput = unknown,\n> = {\n  method: TMethod\n  validateClient?: boolean\n  middleware?: Constrain<TMiddlewares, ReadonlyArray<AnyMiddleware>>\n  validator?: ConstrainValidator<TInput>\n  extractedFn?: CompiledFetcherFn<TResponse>\n  serverFn?: ServerFn<TMethod, TMiddlewares, TInput, TResponse>\n  filename: string\n  functionId: string\n}\n\nexport type ConstrainValidator<TValidator> = unknown extends TValidator\n  ? TValidator\n  : Constrain<\n      TValidator,\n      Validator<\n        DefaultTransformerStringify<ResolveValidatorInput<TValidator>>,\n        any\n      >\n    >\n\ntype ServerFnBase<\n  TMethod extends Method = 'GET',\n  TResponse = unknown,\n  TMiddlewares = unknown,\n  TValidator = unknown,\n> = {\n  options: ServerFnBaseOptions<TMethod, TResponse, TMiddlewares, TValidator>\n  middleware: <const TNewMiddlewares>(\n    middlewares: Constrain<TNewMiddlewares, ReadonlyArray<AnyMiddleware>>,\n  ) => Pick<\n    ServerFnBase<TMethod, TResponse, TNewMiddlewares, TValidator>,\n    'validator' | 'handler'\n  >\n  validator: <TValidator>(\n    validator: ConstrainValidator<TValidator>,\n  ) => Pick<\n    ServerFnBase<TMethod, TResponse, TMiddlewares, TValidator>,\n    'handler' | 'middleware'\n  >\n  handler: <TNewResponse>(\n    fn?: ServerFn<TMethod, TMiddlewares, TValidator, TNewResponse>,\n  ) => Fetcher<TMiddlewares, TValidator, TNewResponse>\n}\n\nexport function createServerFn<\n  TMethod extends Method,\n  TResponse = unknown,\n  TMiddlewares = undefined,\n  TValidator = undefined,\n>(\n  options?: {\n    method: TMethod\n  },\n  __opts?: ServerFnBaseOptions<TMethod, TResponse, TMiddlewares, TValidator>,\n): ServerFnBase<TMethod, TResponse, TMiddlewares, TValidator> {\n  const resolvedOptions = (__opts || options || {}) as ServerFnBaseOptions<\n    TMethod,\n    TResponse,\n    TMiddlewares,\n    TValidator\n  >\n\n  if (typeof resolvedOptions.method === 'undefined') {\n    resolvedOptions.method = 'GET' as TMethod\n  }\n\n  return {\n    options: resolvedOptions as any,\n    middleware: (middleware) => {\n      return createServerFn<TMethod, TResponse, TMiddlewares, TValidator>(\n        undefined,\n        Object.assign(resolvedOptions, { middleware }),\n      ) as any\n    },\n    validator: (validator) => {\n      return createServerFn<TMethod, TResponse, TMiddlewares, TValidator>(\n        undefined,\n        Object.assign(resolvedOptions, { validator }),\n      ) as any\n    },\n    handler: (...args) => {\n      // This function signature changes due to AST transformations\n      // in the babel plugin. We need to cast it to the correct\n      // function signature post-transformation\n      const [extractedFn, serverFn] = args as unknown as [\n        CompiledFetcherFn<TResponse>,\n        ServerFn<TMethod, TMiddlewares, TValidator, TResponse>,\n      ]\n\n      // Keep the original function around so we can use it\n      // in the server environment\n      Object.assign(resolvedOptions, {\n        ...extractedFn,\n        extractedFn,\n        serverFn,\n      })\n\n      invariant(\n        extractedFn.url,\n        `createServerFn must be called with a function that is marked with the 'use server' pragma. Are you using the @tanstack/start-vite-plugin ?`,\n      )\n\n      const resolvedMiddleware = [\n        ...(resolvedOptions.middleware || []),\n        serverFnBaseToMiddleware(resolvedOptions),\n      ]\n\n      // We want to make sure the new function has the same\n      // properties as the original function\n      return Object.assign(\n        async (opts?: CompiledFetcherFnOptions) => {\n          // Start by executing the client-side middleware chain\n          return executeMiddleware(resolvedMiddleware, 'client', {\n            ...extractedFn,\n            method: resolvedOptions.method,\n            data: opts?.data as any,\n            headers: opts?.headers,\n            context: Object.assign({}, extractedFn),\n          }).then((d) => d.result)\n        },\n        {\n          // This copies over the URL, function ID and filename\n          ...extractedFn,\n          // The extracted function on the server-side calls\n          // this function\n          __executeServer: (opts: any) => {\n            const parsedOpts =\n              opts instanceof FormData ? extractFormDataContext(opts) : opts\n\n            return executeMiddleware(resolvedMiddleware, 'server', {\n              ...extractedFn,\n              ...parsedOpts,\n            }).then((d) => ({\n              // Only send the result and sendContext back to the client\n              result: d.result,\n              context: d.sendContext,\n            }))\n          },\n        },\n      ) as any\n    },\n  }\n}\n\nfunction extractFormDataContext(formData: FormData) {\n  const serializedContext = formData.get('__TSR_CONTEXT')\n  formData.delete('__TSR_CONTEXT')\n\n  if (typeof serializedContext !== 'string') {\n    return {\n      context: {},\n      data: formData,\n    }\n  }\n\n  try {\n    const context = defaultTransformer.parse(serializedContext)\n    return {\n      context,\n      data: formData,\n    }\n  } catch (e) {\n    return {\n      data: formData,\n    }\n  }\n}\n\nfunction flattenMiddlewares(\n  middlewares: Array<AnyMiddleware>,\n): Array<AnyMiddleware> {\n  const flattened: Array<AnyMiddleware> = []\n\n  const recurse = (middleware: Array<AnyMiddleware>) => {\n    middleware.forEach((m) => {\n      if (m.options.middleware) {\n        recurse(m.options.middleware)\n      }\n      flattened.push(m)\n    })\n  }\n\n  recurse(middlewares)\n\n  return flattened\n}\n\nexport type MiddlewareOptions = {\n  method: Method\n  data: any\n  headers?: HeadersInit\n  sendContext?: any\n  context?: any\n}\n\nexport type MiddlewareResult = {\n  context: any\n  sendContext: any\n  data: any\n  result: unknown\n}\n\nconst applyMiddleware = (\n  middlewareFn: NonNullable<\n    | AnyMiddleware['options']['client']\n    | AnyMiddleware['options']['server']\n    | AnyMiddleware['options']['clientAfter']\n  >,\n  mCtx: MiddlewareOptions,\n  nextFn: (ctx: MiddlewareOptions) => Promise<MiddlewareResult>,\n) => {\n  return middlewareFn({\n    data: mCtx.data,\n    context: mCtx.context,\n    sendContext: mCtx.sendContext,\n    method: mCtx.method,\n    next: ((userResult: any) => {\n      // Take the user provided context\n      // and merge it with the current context\n      const context = {\n        ...mCtx.context,\n        ...userResult?.context,\n      }\n\n      const sendContext = {\n        ...mCtx.sendContext,\n        ...(userResult?.sendContext ?? {}),\n      }\n\n      const headers = mergeHeaders(mCtx.headers, userResult?.headers)\n\n      // Return the next middleware\n      return nextFn({\n        method: mCtx.method,\n        data: mCtx.data,\n        context,\n        sendContext,\n        headers,\n        result: userResult?.result ?? (mCtx as any).result,\n      } as MiddlewareResult & {\n        method: Method\n      })\n    }) as any,\n  })\n}\n\nfunction execValidator(validator: AnyValidator, input: unknown): unknown {\n  if (validator == null) return {}\n\n  if ('~standard' in validator) {\n    const result = validator['~standard'].validate(input)\n\n    if ('value' in result) return result.value\n\n    if (result instanceof Promise)\n      throw new Error('Async validation not supported')\n\n    throw new Error(JSON.stringify(result.issues, undefined, 2))\n  }\n\n  if ('parse' in validator) {\n    return validator.parse(input)\n  }\n\n  if (typeof validator === 'function') {\n    return validator(input)\n  }\n\n  throw new Error('Invalid validator type!')\n}\n\nasync function executeMiddleware(\n  middlewares: Array<AnyMiddleware>,\n  env: 'client' | 'server',\n  opts: MiddlewareOptions,\n): Promise<MiddlewareResult> {\n  const flattenedMiddlewares = flattenMiddlewares(middlewares)\n\n  const next = async (ctx: MiddlewareOptions): Promise<MiddlewareResult> => {\n    // Get the next middleware\n    const nextMiddleware = flattenedMiddlewares.shift()\n\n    // If there are no more middlewares, return the context\n    if (!nextMiddleware) {\n      return ctx as any\n    }\n\n    if (\n      nextMiddleware.options.validator &&\n      (env === 'client' ? nextMiddleware.options.validateClient : true)\n    ) {\n      // Execute the middleware's input function\n      ctx.data = await execValidator(nextMiddleware.options.validator, ctx.data)\n    }\n\n    const middlewareFn =\n      env === 'client'\n        ? nextMiddleware.options.client\n        : nextMiddleware.options.server\n\n    if (middlewareFn) {\n      // Execute the middleware\n      return applyMiddleware(\n        middlewareFn,\n        ctx,\n        async (userCtx): Promise<MiddlewareResult> => {\n          // If there is a clientAfter function and we are on the client\n          if (env === 'client' && nextMiddleware.options.clientAfter) {\n            // We need to await the next middleware and get the result\n            const result = await next(userCtx)\n            // Then we can execute the clientAfter function\n            return applyMiddleware(\n              nextMiddleware.options.clientAfter,\n              result as any,\n              // Identity, because there \"next\" is just returning\n              (d: any) => d,\n            ) as any\n          }\n\n          return next(userCtx)\n        },\n      ) as any\n    }\n\n    return next(ctx)\n  }\n\n  // Start the middleware chain\n  return next({\n    ...opts,\n    headers: opts.headers || {},\n    sendContext: (opts as any).sendContext || {},\n    context: opts.context || {},\n  })\n}\n\nfunction serverFnBaseToMiddleware(\n  options: ServerFnBaseOptions<any, any, any, any>,\n): AnyMiddleware {\n  return {\n    _types: undefined!,\n    options: {\n      validator: options.validator,\n      validateClient: options.validateClient,\n      client: async ({ next, sendContext, ...ctx }) => {\n        // Execute the extracted function\n        // but not before serializing the context\n        const res = await options.extractedFn?.({\n          ...ctx,\n          // switch the sendContext over to context\n          context: sendContext,\n        } as any)\n\n        return next(res)\n      },\n      server: async ({ next, ...ctx }) => {\n        // Execute the server function\n        const result = await options.serverFn?.(ctx as any)\n\n        return next({\n          result,\n        } as any)\n      },\n    },\n  }\n}\n", "import type { ConstrainValidator, Method } from './createServerFn'\nimport type {\n  Constrain,\n  DefaultTransformerStringify,\n  Expand,\n  MergeAll,\n  ResolveValidatorInput,\n  ResolveValidatorOutput,\n} from '@tanstack/react-router'\n\n/**\n * Turns all middleware into a union\n */\nexport type ParseMiddlewares<\n  TMiddlewares,\n  TAcc = never,\n> = unknown extends TMiddlewares\n  ? TAcc\n  : [] extends TMiddlewares\n    ? TAcc\n    : TMiddlewares extends ReadonlyArray<AnyMiddleware>\n      ? TMiddlewares[number] extends infer TMiddleware extends AnyMiddleware\n        ? TMiddleware extends any\n          ? ParseMiddlewares<\n              TMiddleware['_types']['middlewares'],\n              TAcc | TMiddleware\n            >\n          : TAcc\n        : TAcc\n      : TAcc\n\nexport type ResolveAllMiddlewareServerContext<\n  TMiddlewares,\n  TContext = undefined,\n> = ParseMiddlewares<TMiddlewares>['_types']['serverContext'] | TContext\n\n/**\n * Recursively resolve the server context type produced by a sequence of middleware\n */\nexport type MergeAllServerContext<TMiddlewares, TContext = undefined> = Expand<\n  MergeAll<\n    ResolveAllMiddlewareServerContext<TMiddlewares, TContext> extends undefined\n      ? undefined\n      : NonNullable<ResolveAllMiddlewareServerContext<TMiddlewares, TContext>>\n  >\n>\n\nexport type ResolveAllMiddlewareClientContext<\n  TMiddlewares,\n  TContext = undefined,\n> = ParseMiddlewares<TMiddlewares>['_types']['clientContext'] | TContext\n\n/**\n * Recursively resolve the client context type produced by a sequence of middleware\n */\nexport type MergeAllClientContext<TMiddlewares, TContext = undefined> = Expand<\n  MergeAll<\n    ResolveAllMiddlewareClientContext<TMiddlewares, TContext> extends undefined\n      ? undefined\n      : NonNullable<ResolveAllMiddlewareClientContext<TMiddlewares, TContext>>\n  >\n>\n\nexport type ResolveAllMiddlewareClientAfterContext<\n  TMiddlewares,\n  TContext = undefined,\n> =\n  | ParseMiddlewares<TMiddlewares>['_types']['clientContext']\n  | ParseMiddlewares<TMiddlewares>['_types']['clientAfterContext']\n  | TContext\n\nexport type MergeAllClientAfterContext<\n  TMiddlewares,\n  TClientContext = undefined,\n  TClientAfterContext = undefined,\n> = Expand<\n  MergeAll<\n    ResolveAllMiddlewareClientAfterContext<\n      TMiddlewares,\n      TClientContext | TClientAfterContext\n    > extends undefined\n      ? undefined\n      : NonNullable<\n          ResolveAllMiddlewareClientAfterContext<\n            TMiddlewares,\n            TClientContext | TClientAfterContext\n          >\n        >\n  >\n>\n\nexport type ResolveAllValidators<TMiddlewares, TValidator> =\n  | ParseMiddlewares<TMiddlewares>['_types']['validator']\n  | TValidator\n\nexport type ResolveAllValidatorInputs<TMiddlewares, TValidator> =\n  ResolveAllValidators<TMiddlewares, TValidator> extends undefined\n    ? undefined\n    : ResolveValidatorInput<\n        NonNullable<ResolveAllValidators<TMiddlewares, TValidator>>\n      >\n\n/**\n * Recursively resolve the input type produced by a sequence of middleware\n */\nexport type MergeAllValidatorInputs<TMiddlewares, TValidator> = Expand<\n  MergeAll<ResolveAllValidatorInputs<TMiddlewares, TValidator>>\n>\n\nexport type ResolveAllValidatorOutputs<TMiddlewares, TValidator> =\n  ResolveAllValidators<TMiddlewares, TValidator> extends undefined\n    ? undefined\n    : ResolveValidatorOutput<\n        NonNullable<ResolveAllValidators<TMiddlewares, TValidator>>\n      >\n\n/**\n * Recursively merge the output type produced by a sequence of middleware\n */\nexport type MergeAllValidatorOutputs<TMiddlewares, TValidator> = Expand<\n  MergeAll<ResolveAllValidatorOutputs<TMiddlewares, TValidator>>\n>\n\nexport interface MiddlewareOptions<\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n> {\n  validateClient?: boolean\n  middleware?: TMiddlewares\n  validator?: ConstrainValidator<TValidator>\n  client?: MiddlewareClientFn<\n    TMiddlewares,\n    TValidator,\n    TServerContext,\n    TClientContext\n  >\n  server?: MiddlewareServerFn<\n    TMiddlewares,\n    TValidator,\n    TServerContext,\n    unknown,\n    unknown\n  >\n  clientAfter?: MiddlewareClientAfterFn<\n    TMiddlewares,\n    TValidator,\n    TClientContext,\n    unknown,\n    unknown\n  >\n}\n\nexport type MiddlewareServerFn<\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TNewServerContext,\n  TNewClientAfterContext,\n> = (options: {\n  data: MergeAllValidatorOutputs<TMiddlewares, NonNullable<TValidator>>\n  context: MergeAllServerContext<TMiddlewares, NonNullable<TServerContext>>\n  next: <\n    TNewServerContext = undefined,\n    TNewClientAfterContext = undefined,\n  >(ctx?: {\n    context?: TNewServerContext\n    sendContext?: DefaultTransformerStringify<TNewClientAfterContext>\n  }) => Promise<\n    ServerResultWithContext<TNewServerContext, TNewClientAfterContext>\n  >\n}) =>\n  | Promise<ServerResultWithContext<TNewServerContext, TNewClientAfterContext>>\n  | ServerResultWithContext<TNewServerContext, TNewClientAfterContext>\n\nexport type MiddlewareClientFn<\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n> = (options: {\n  data: MergeAllValidatorInputs<TMiddlewares, NonNullable<TValidator>>\n  context: MergeAllClientContext<TMiddlewares>\n  sendContext?: unknown // cc Chris Horobin\n  method: Method\n  next: <TNewServerContext = undefined, TNewClientContext = undefined>(ctx?: {\n    context?: TNewClientContext\n    sendContext?: DefaultTransformerStringify<TNewServerContext>\n    headers?: HeadersInit\n  }) => Promise<ClientResultWithContext<TNewServerContext, TNewClientContext>>\n}) =>\n  | Promise<ClientResultWithContext<TServerContext, TClientContext>>\n  | ClientResultWithContext<TServerContext, TClientContext>\n\nexport type MiddlewareClientAfterFn<\n  TMiddlewares,\n  TValidator,\n  TClientContext,\n  TClientAfterContext,\n  TNewClientAfterContext,\n> = (options: {\n  data: MergeAllValidatorInputs<TMiddlewares, NonNullable<TValidator>>\n  context: MergeAllClientAfterContext<\n    TMiddlewares,\n    TClientContext,\n    TClientAfterContext\n  >\n  method: Method\n  next: <TNewClientAfterContext = undefined>(ctx?: {\n    context?: TNewClientAfterContext\n    sendContext?: never\n    headers?: HeadersInit\n  }) => Promise<ClientAfterResultWithContext<TNewClientAfterContext>>\n}) =>\n  | Promise<ClientAfterResultWithContext<TNewClientAfterContext>>\n  | ClientAfterResultWithContext<TNewClientAfterContext>\n\nexport type ServerResultWithContext<TContext, TClientAfterContext> = {\n  'use functions must return the result of next()': true\n  context: TContext\n  clientAfterContext: TClientAfterContext\n}\n\nexport type ClientAfterResultWithContext<TClientContext> = {\n  'use functions must return the result of next()': true\n  context: TClientContext\n  headers: HeadersInit\n}\n\nexport type ClientResultWithContext<TServerContext, TClientContext> = {\n  'use functions must return the result of next()': true\n  context: TClientContext\n  serverContext: TServerContext\n  headers: HeadersInit\n}\n\nexport type AnyMiddleware = MiddlewareTypes<any, any, any, any, any, any>\n\nexport interface MiddlewareTypes<\n  TId,\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n  TClientAfterContext,\n> {\n  _types: {\n    id: TId\n    middlewares: TMiddlewares\n    input: ResolveValidatorInput<TValidator>\n    output: ResolveValidatorOutput<TValidator>\n    clientContext: TClientContext\n    serverContext: TServerContext\n    clientAfterContext: TClientAfterContext\n    validator: TValidator\n  }\n  options: MiddlewareOptions<\n    TMiddlewares,\n    TValidator,\n    TServerContext,\n    TClientContext\n  >\n}\n\nexport interface MiddlewareValidator<\n  TId,\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n  TClientAfterContext,\n> {\n  validator: <TNewValidator>(\n    input: ConstrainValidator<TNewValidator>,\n  ) => MiddlewareAfterMiddleware<\n    TId,\n    TMiddlewares,\n    NonNullable<TValidator> | TNewValidator,\n    TServerContext,\n    TClientContext,\n    TClientAfterContext\n  >\n}\n\nexport interface MiddlewareClientAfter<\n  TId,\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n  TClientAfterContext,\n> {\n  clientAfter: <TNewClientAfterContext = undefined>(\n    clientAfter: MiddlewareClientAfterFn<\n      TMiddlewares,\n      TValidator,\n      TClientContext,\n      TClientAfterContext,\n      TNewClientAfterContext\n    >,\n  ) => MiddlewareAfterServer<\n    TId,\n    TMiddlewares,\n    TValidator,\n    TServerContext,\n    TClientContext,\n    TClientAfterContext | TNewClientAfterContext\n  >\n}\n\nexport interface MiddlewareAfterServer<\n  TId,\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n  TClientAfterContext,\n> extends MiddlewareTypes<\n      TId,\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TClientContext,\n      TClientAfterContext\n    >,\n    MiddlewareClientAfter<\n      TId,\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TClientContext,\n      TClientAfterContext\n    > {}\n\nexport interface MiddlewareServer<\n  TId,\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n  TClientAfterContext,\n> {\n  server: <TNewServerContext = undefined, TNewClientAfterContext = undefined>(\n    server: MiddlewareServerFn<\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TNewServerContext,\n      TNewClientAfterContext\n    >,\n  ) => MiddlewareAfterServer<\n    TId,\n    TMiddlewares,\n    TValidator,\n    TServerContext | TNewServerContext,\n    TClientContext,\n    TClientAfterContext | TNewClientAfterContext\n  >\n}\n\nexport interface MiddlewareAfterClient<\n  TId,\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n  TClientAfterContext,\n> extends MiddlewareTypes<\n      TId,\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TClientContext,\n      TClientAfterContext\n    >,\n    MiddlewareServer<\n      TId,\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TClientContext,\n      TClientAfterContext\n    > {}\n\nexport interface MiddlewareClient<\n  TId,\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n  TClientAfterContext,\n> {\n  client: <TNewServerContext = undefined, TNewClientContext = undefined>(\n    client: MiddlewareClientFn<\n      TMiddlewares,\n      TValidator,\n      TNewServerContext,\n      TNewClientContext\n    >,\n  ) => MiddlewareAfterClient<\n    TId,\n    TMiddlewares,\n    TValidator,\n    TServerContext | TNewServerContext,\n    TClientContext | TNewClientContext,\n    TClientAfterContext\n  >\n}\n\nexport interface MiddlewareAfterMiddleware<\n  TId,\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n  TClientAfterContext,\n> extends MiddlewareTypes<\n      TId,\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TClientContext,\n      TClientAfterContext\n    >,\n    MiddlewareServer<\n      TId,\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TClientContext,\n      TClientAfterContext\n    >,\n    MiddlewareClient<\n      TId,\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TClientContext,\n      TClientAfterContext\n    >,\n    MiddlewareValidator<\n      TId,\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TClientContext,\n      TClientAfterContext\n    > {}\n\nexport interface Middleware<\n  TId,\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n  TClientAfterContext,\n> extends MiddlewareAfterMiddleware<\n    TId,\n    TMiddlewares,\n    TValidator,\n    TServerContext,\n    TClientContext,\n    TClientAfterContext\n  > {\n  middleware: <const TNewMiddlewares>(\n    middlewares: Constrain<TNewMiddlewares, ReadonlyArray<AnyMiddleware>>,\n  ) => MiddlewareAfterMiddleware<\n    TId,\n    TNewMiddlewares,\n    TValidator,\n    TServerContext,\n    TClientContext,\n    TClientAfterContext\n  >\n}\n\nexport function createMiddleware<\n  const TId,\n  const TMiddlewares,\n  TValidator = undefined,\n  TServerContext = undefined,\n  TClientContext = undefined,\n  TClientAfterContext = undefined,\n>(\n  options?: {\n    validateClient?: boolean\n  },\n  __opts?: MiddlewareOptions<\n    TMiddlewares,\n    TValidator,\n    TServerContext,\n    TClientContext\n  >,\n): Middleware<\n  TId,\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n  TClientAfterContext\n> {\n  // const resolvedOptions = (__opts || options) as MiddlewareOptions<\n  const resolvedOptions =\n    __opts ||\n    ((options || {}) as MiddlewareOptions<\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TClientContext\n    >)\n\n  return {\n    options: resolvedOptions as any,\n    middleware: (middleware: any) => {\n      return createMiddleware<\n        TId,\n        TMiddlewares,\n        TValidator,\n        TServerContext,\n        TClientContext\n      >(undefined, Object.assign(resolvedOptions, { middleware })) as any\n    },\n    validator: (validator: any) => {\n      return createMiddleware<\n        TId,\n        TMiddlewares,\n        TValidator,\n        TServerContext,\n        TClientContext\n      >(undefined, Object.assign(resolvedOptions, { validator })) as any\n    },\n    client: (client: any) => {\n      return createMiddleware<\n        TId,\n        TMiddlewares,\n        TValidator,\n        TServerContext,\n        TClientContext\n      >(undefined, Object.assign(resolvedOptions, { client })) as any\n    },\n    server: (server: any) => {\n      return createMiddleware<\n        TId,\n        TMiddlewares,\n        TValidator,\n        TServerContext,\n        TClientContext\n      >(undefined, Object.assign(resolvedOptions, { server })) as any\n    },\n    clientAfter: (clientAfter: any) => {\n      return createMiddleware<\n        TId,\n        TMiddlewares,\n        TValidator,\n        TServerContext,\n        TClientContext\n      >(undefined, Object.assign(resolvedOptions, { clientAfter })) as any\n    },\n  } as unknown as Middleware<\n    TId,\n    TMiddlewares,\n    TValidator,\n    TServerContext,\n    TClientContext,\n    TClientAfterContext\n  >\n}\n", "// A function that will have its contents removed on the client build and only be available on the server build\n// it can accept any value, a function that will return a value, or an async function that will return a value\n\nexport function serverOnly<T>(value: () => T): () => T | undefined {\n  return value\n}\n", "export function DehydrateRouter() {\n  return null\n}\n", "import type { JsonResponse } from './createServerFn'\n\nexport function json<TData>(\n  payload: TData,\n  opts?: {\n    status?: number\n    statusText?: string\n    headers?: HeadersInit\n  },\n): JsonResponse<TData> {\n  const status = opts?.status || 200\n  const statusText = opts?.statusText\n\n  return new Response(JSON.stringify(payload), {\n    status,\n    statusText,\n    headers: {\n      'Content-Type': 'application/json',\n      ...opts?.headers,\n    },\n  })\n}\n", "import { createContext } from 'react'\n\nclass Context {\n  cache = new Map()\n\n  private static instance: Context | undefined\n\n  public static create(): Context {\n    if (!Context.instance) {\n      Context.instance = new Context()\n    }\n\n    return Context.instance\n  }\n\n  private createContext<T>(key: string, initialValue: T) {\n    const context = createContext(initialValue)\n\n    this.cache.set(key, context)\n\n    return context\n  }\n\n  get<T>(key: string, initialValue?: T) {\n    return this.cache.get(key) || this.createContext(key, initialValue)\n  }\n}\n\nconst context = Context.create()\n\nexport default context\n", "import { ScriptOnce, useRouter, useRouterState } from '@tanstack/react-router'\nimport * as React from 'react'\nimport jsesc from 'jsesc'\nimport { Context } from '@tanstack/react-cross-context'\nimport { Asset } from './Asset'\nimport type { RouterManagedTag } from '@tanstack/react-router'\n\nexport const useMeta = () => {\n  const router = useRouter()\n\n  const routeMeta = useRouterState({\n    select: (state) => {\n      return state.matches.map((match) => match.meta!).filter(Boolean)\n    },\n  })\n\n  const meta: Array<RouterManagedTag> = React.useMemo(() => {\n    const resultMeta: Array<RouterManagedTag> = []\n    const metaByAttribute: Record<string, true> = {}\n    let title: RouterManagedTag | undefined\n    ;[...routeMeta].reverse().forEach((metas) => {\n      ;[...metas].reverse().forEach((m) => {\n        if (!m) return\n\n        if (m.title) {\n          if (!title) {\n            title = {\n              tag: 'title',\n              children: m.title,\n            }\n          }\n        } else {\n          const attribute = m.name ?? m.property\n          if (attribute) {\n            if (metaByAttribute[attribute]) {\n              return\n            } else {\n              metaByAttribute[attribute] = true\n            }\n          }\n\n          resultMeta.push({\n            tag: 'meta',\n            attrs: {\n              ...m,\n            },\n          })\n        }\n      })\n    })\n\n    if (title) {\n      resultMeta.push(title)\n    }\n\n    resultMeta.reverse()\n\n    return resultMeta\n  }, [routeMeta])\n\n  const links = useRouterState({\n    select: (state) =>\n      state.matches\n        .map((match) => match.links!)\n        .filter(Boolean)\n        .flat(1)\n        .map((link) => ({\n          tag: 'link',\n          attrs: {\n            ...link,\n          },\n        })) as Array<RouterManagedTag>,\n    structuralSharing: true as any,\n  })\n\n  const preloadMeta = useRouterState({\n    select: (state) => {\n      const preloadMeta: Array<RouterManagedTag> = []\n\n      state.matches\n        .map((match) => router.looseRoutesById[match.routeId]!)\n        .forEach((route) =>\n          router.manifest?.routes[route.id]?.preloads\n            ?.filter(Boolean)\n            .forEach((preload) => {\n              preloadMeta.push({\n                tag: 'link',\n                attrs: {\n                  rel: 'modulepreload',\n                  href: preload,\n                },\n              })\n            }),\n        )\n\n      return preloadMeta\n    },\n    structuralSharing: true as any,\n  })\n\n  return uniqBy(\n    [...meta, ...preloadMeta, ...links] as Array<RouterManagedTag>,\n    (d) => {\n      return JSON.stringify(d)\n    },\n  )\n}\n\nexport const useMetaElements = () => {\n  const router = useRouter()\n  const meta = useMeta()\n\n  const dehydratedCtx = React.useContext(\n    Context.get('TanStackRouterHydrationContext', {}),\n  )\n\n  return (\n    <>\n      {meta.map((asset, i) => (\n        <Asset {...asset} key={`tsr-meta-${JSON.stringify(asset)}`} />\n      ))}\n      <>\n        <ScriptOnce\n          log={false}\n          // This is the raw version of the minified script below\n          // children={`\n          // __TSR__ = {\n          //   matches: [],\n          //   streamedValues: {},\n          //   queue: [],\n          //   runQueue: () => {\n          //     let changed = false\n          //     __TSR__.queue = __TSR__.queue.filter((fn) => {\n          //       if (fn()) {\n          //         changed = true\n          //         return false\n          //       }\n          //       return true\n          //     })\n          //     if (changed) {\n          //       __TSR__.runQueue()\n          //     }\n          //   },\n          //   initMatch: (match) => {\n          //     __TSR__.queue.push(() => {\n          //       if (!__TSR__.matches[match.index]) {\n          //         __TSR__.matches[match.index] = match\n          //         Object.entries(match.extracted).forEach(([id, ex]) => {\n          //           if (ex.type === 'stream') {\n          //             let controller\n          //             ex.value = new ReadableStream({\n          //               start(c) {\n          //                 controller = c\n          //               },\n          //             })\n          //             ex.value.controller = controller\n          //           } else if (ex.type === 'promise') {\n          //             let r, j\n          //             ex.value = new Promise((r_, j_) => {\n          //               ;(r = r_), (j = j_)\n          //             })\n          //             ex.resolve = r\n          //             ex.reject = j\n          //           }\n          //         })\n          //       }\n\n          //       return true\n          //     })\n\n          //     __TSR__.runQueue()\n          //   },\n          //   resolvePromise: (entry) => {\n          //     __TSR__.queue.push(() => {\n          //       const match = __TSR__.matches[entry.matchIndex]\n          //       if (match) {\n          //         const ex = match.extracted[entry.id]\n          //         if (ex) {\n          //           ex.resolve(entry.value.data)\n          //           return true\n          //         }\n          //       }\n          //       return false\n          //     })\n\n          //     __TSR__.runQueue()\n          //   },\n          //   cleanScripts: () => {\n          //     document.querySelectorAll('.tsr-once').forEach((el) => {\n          //       el.remove()\n          //     })\n          //   },\n          // }\n          //   `}\n          // This is the minified version of the script above, using https://try.terser.org/\n          // Is this archaic? Probably. But we're not going to edit this much, so it's fine.\n          // In a future world, like bun, we could use a more modern approach, like a compile-time macro minifier.\n          children={`__TSR__={matches:[],streamedValues:{},queue:[],runQueue:()=>{let e=!1;__TSR__.queue=__TSR__.queue.filter((_=>!_()||(e=!0,!1))),e&&__TSR__.runQueue()},initMatch:e=>{__TSR__.queue.push((()=>(__TSR__.matches[e.index]||(__TSR__.matches[e.index]=e,Object.entries(e.extracted).forEach((([e,_])=>{if(\"stream\"===_.type){let e;_.value=new ReadableStream({start(_){e=_}}),_.value.controller=e}else if(\"promise\"===_.type){let e,t;_.value=new Promise(((_,u)=>{e=_,t=u})),_.resolve=e,_.reject=t}}))),!0))),__TSR__.runQueue()},resolvePromise:e=>{__TSR__.queue.push((()=>{const _=__TSR__.matches[e.matchIndex];if(_){const t=_.extracted[e.id];if(t)return t.resolve(e.value.data),!0}return!1})),__TSR__.runQueue()},cleanScripts:()=>{document.querySelectorAll(\".tsr-once\").forEach((e=>{e.remove()}))}};`}\n        />\n        <ScriptOnce\n          children={`__TSR__.dehydrated = ${jsesc(\n            router.options.transformer.stringify(dehydratedCtx),\n            {\n              isScriptContext: true,\n              wrap: true,\n              json: true,\n            },\n          )}`}\n        />\n      </>\n    </>\n  )\n}\n\n/**\n * @description The `Meta` component is used to render meta tags and links for the current route.\n * It should be rendered in the `<head>` of your document.\n */\nexport const Meta = () => {\n  return <>{useMetaElements()}</>\n}\n\nfunction uniqBy<T>(arr: Array<T>, fn: (item: T) => string) {\n  const seen = new Set<string>()\n  return arr.filter((item) => {\n    const key = fn(item)\n    if (seen.has(key)) {\n      return false\n    }\n    seen.add(key)\n    return true\n  })\n}\n", "import { useRouter, useRouterState } from '@tanstack/react-router'\nimport { Asset } from './Asset'\nimport type { RouterManagedTag } from '@tanstack/react-router'\n\nexport const Scripts = () => {\n  const router = useRouter()\n\n  const assetScripts = useRouterState({\n    select: (state) => {\n      const assetScripts: Array<RouterManagedTag> = []\n\n      state.matches\n        .map((match) => router.looseRoutesById[match.routeId]!)\n        .forEach((route) =>\n          router.manifest?.routes[route.id]?.assets\n            ?.filter((d) => d.tag === 'script')\n            .forEach((asset) => {\n              assetScripts.push({\n                tag: 'script',\n                attrs: asset.attrs,\n                children: asset.children,\n              } as any)\n            }),\n        )\n\n      return assetScripts\n    },\n    structuralSharing: true as any,\n  })\n\n  const { scripts } = useRouterState({\n    select: (state) => ({\n      scripts: (\n        state.matches\n          .map((match) => match.scripts!)\n          .filter(Boolean)\n          .flat(1) as Array<RouterManagedTag>\n      ).map(({ children, ...script }) => ({\n        tag: 'script',\n        attrs: {\n          ...script,\n          suppressHydrationWarning: true,\n        },\n        children,\n      })),\n    }),\n  })\n\n  const allScripts = [...scripts, ...assetScripts] as Array<RouterManagedTag>\n\n  return (\n    <>\n      {allScripts.map((asset, i) => (\n        // eslint-disable-next-line @eslint-react/no-array-index-key\n        <Asset {...asset} key={`tsr-scripts-${asset.tag}-${i}`} />\n      ))}\n    </>\n  )\n}\n", "import * as React from 'react'\nimport {\n  ScriptOnce,\n  createControlledPromise,\n  defer,\n  isPlainArray,\n  isPlainObject,\n  pick,\n  useRouter,\n} from '@tanstack/react-router'\nimport jsesc from 'jsesc'\nimport invariant from 'tiny-invariant'\nimport type {\n  AnyRouteMatch,\n  AnyRouter,\n  ExtractedEntry,\n  StreamState,\n} from '@tanstack/react-router'\n\nexport function serializeLoaderData(\n  dataType: '__beforeLoadContext' | 'loaderData',\n  data: any,\n  ctx: {\n    match: AnyRouteMatch\n    router: AnyRouter\n  },\n) {\n  if (!ctx.router.isServer) {\n    return data\n  }\n\n  ;(ctx.match as any).extracted = (ctx.match as any).extracted || []\n\n  const extracted = (ctx.match as any).extracted\n\n  const replacedLoaderData = replaceBy(data, (value, path) => {\n    const type =\n      value instanceof ReadableStream\n        ? 'stream'\n        : value instanceof Promise\n          ? 'promise'\n          : undefined\n\n    if (type) {\n      const entry: ExtractedEntry = {\n        dataType,\n        type,\n        path,\n        id: extracted.length,\n        value,\n        matchIndex: ctx.match.index,\n      }\n\n      extracted.push(entry)\n\n      // If it's a stream, we need to tee it so we can read it multiple times\n      if (type === 'stream') {\n        const [copy1, copy2] = value.tee()\n        entry.streamState = createStreamState({ stream: copy2 })\n\n        return copy1\n      } else {\n        defer(value)\n      }\n    }\n\n    return value\n  })\n\n  return replacedLoaderData\n}\n\n// Right after hydration and before the first render, we need to rehydrate each match\n// This includes rehydrating the loaderData and also using the beforeLoadContext\n// to reconstruct any context that was serialized on the server\nexport function afterHydrate({ router }: { router: AnyRouter }) {\n  router.state.matches.forEach((match) => {\n    const route = router.looseRoutesById[match.routeId]!\n    const dMatch = window.__TSR__?.matches[match.index]\n    if (dMatch) {\n      const parentMatch = router.state.matches[match.index - 1]\n      const parentContext = parentMatch?.context ?? router.options.context ?? {}\n      if (dMatch.__beforeLoadContext) {\n        match.__beforeLoadContext = router.options.transformer.parse(\n          dMatch.__beforeLoadContext,\n        ) as any\n\n        match.context = {\n          ...parentContext,\n          ...match.context,\n          ...match.__beforeLoadContext,\n        }\n      }\n\n      if (dMatch.loaderData) {\n        match.loaderData = router.options.transformer.parse(dMatch.loaderData)\n      }\n\n      const extracted = dMatch.extracted\n\n      if (extracted) {\n        Object.entries(extracted).forEach(([_, ex]: any) => {\n          if (ex.value instanceof Promise) {\n            const og = ex.value\n            ex.value = og.then((data: any) => {\n              return data\n            })\n          }\n          deepMutableSetByPath(match, ['loaderData', ...ex.path], ex.value)\n        })\n      }\n    }\n\n    const headFnContent = route.options.head?.({\n      matches: router.state.matches,\n      match,\n      params: match.params,\n      loaderData: match.loaderData,\n    })\n\n    Object.assign(match, {\n      meta: headFnContent?.meta,\n      links: headFnContent?.links,\n      scripts: headFnContent?.scripts,\n    })\n  })\n}\n\nexport function AfterEachMatch(props: { match: any; matchIndex: number }) {\n  const router = useRouter()\n\n  const fullMatch = router.state.matches[props.matchIndex]!\n\n  if (!router.isServer) {\n    return null\n  }\n\n  const extracted = (fullMatch as any).extracted as\n    | undefined\n    | Array<ExtractedEntry>\n\n  const [serializedBeforeLoadData, serializedLoaderData] = (\n    ['__beforeLoadContext', 'loaderData'] as const\n  ).map((dataType) => {\n    return extracted\n      ? extracted.reduce(\n          (acc: any, entry: ExtractedEntry) => {\n            if (entry.dataType !== dataType) {\n              return deepImmutableSetByPath(\n                acc,\n                ['temp', ...entry.path],\n                undefined,\n              )\n            }\n            return acc\n          },\n          { temp: fullMatch[dataType] },\n        ).temp\n      : fullMatch[dataType]\n  })\n\n  if (\n    serializedBeforeLoadData !== undefined ||\n    serializedLoaderData !== undefined ||\n    extracted?.length\n  ) {\n    const initCode = `__TSR__.initMatch(${jsesc(\n      {\n        index: props.matchIndex,\n        __beforeLoadContext: router.options.transformer.stringify(\n          serializedBeforeLoadData,\n        ),\n        loaderData: router.options.transformer.stringify(serializedLoaderData),\n        extracted: extracted\n          ? Object.fromEntries(\n              extracted.map((entry) => {\n                return [entry.id, pick(entry, ['type', 'path'])]\n              }),\n            )\n          : {},\n      },\n      {\n        isScriptContext: true,\n        wrap: true,\n        json: true,\n      },\n    )})`\n\n    return (\n      <>\n        <ScriptOnce children={initCode} />\n        {extracted\n          ? extracted.map((d) => {\n              if (d.type === 'stream') {\n                return <DehydrateStream key={d.id} entry={d} />\n              }\n\n              return <DehydratePromise key={d.id} entry={d} />\n            })\n          : null}\n      </>\n    )\n  }\n\n  return null\n}\n\nexport function replaceBy<T>(\n  obj: T,\n  cb: (value: any, path: Array<string>) => any,\n  path: Array<string> = [],\n): T {\n  if (isPlainArray(obj)) {\n    return obj.map((value, i) => replaceBy(value, cb, [...path, `${i}`])) as any\n  }\n\n  if (isPlainObject(obj)) {\n    // Do not allow objects with illegal\n    const newObj: any = {}\n\n    for (const key in obj) {\n      newObj[key] = replaceBy(obj[key], cb, [...path, key])\n    }\n\n    return newObj\n  }\n\n  // // Detect classes, functions, and other non-serializable objects\n  // // and return undefined. Exclude some known types that are serializable\n  // if (\n  //   typeof obj === 'function' ||\n  //   (typeof obj === 'object' &&\n  //     ![Object, Promise, ReadableStream].includes((obj as any)?.constructor))\n  // ) {\n  //   console.info(obj)\n  //   warning(false, `Non-serializable value ☝️ found at ${path.join('.')}`)\n  //   return undefined as any\n  // }\n\n  const newObj = cb(obj, path)\n\n  if (newObj !== obj) {\n    return newObj\n  }\n\n  return obj\n}\n\nfunction DehydratePromise({ entry }: { entry: ExtractedEntry }) {\n  return (\n    <div className=\"tsr-once\">\n      <React.Suspense fallback={null}>\n        <InnerDehydratePromise entry={entry} />\n      </React.Suspense>\n    </div>\n  )\n}\n\nfunction InnerDehydratePromise({ entry }: { entry: ExtractedEntry }) {\n  const router = useRouter()\n  if (entry.value.status === 'pending') {\n    throw entry.value\n  }\n\n  const code = `__TSR__.resolvePromise(${jsesc(entry, {\n    isScriptContext: true,\n    wrap: true,\n    json: true,\n  })})`\n\n  router.injectScript(code)\n\n  return <></>\n}\n\nfunction DehydrateStream({ entry }: { entry: ExtractedEntry }) {\n  invariant(entry.streamState, 'StreamState should be defined')\n  const router = useRouter()\n\n  return (\n    <StreamChunks\n      streamState={entry.streamState}\n      children={(chunk) => {\n        const code = chunk\n          ? `__TSR__.matches[${entry.matchIndex}].extracted[${entry.id}].value.controller.enqueue(new TextEncoder().encode(${jsesc(\n              chunk.toString(),\n              {\n                isScriptContext: true,\n                wrap: true,\n                json: true,\n              },\n            )}))`\n          : `__TSR__.matches[${entry.matchIndex}].extracted[${entry.id}].value.controller.close()`\n\n        router.injectScript(code)\n\n        return <></>\n      }}\n    />\n  )\n}\n\n// Readable stream with state is a stream that has a promise that resolves to the next chunk\nfunction createStreamState({\n  stream,\n}: {\n  stream: ReadableStream\n}): StreamState {\n  const streamState: StreamState = {\n    promises: [],\n  }\n\n  const reader = stream.getReader()\n\n  const read = (index: number): any => {\n    streamState.promises[index] = createControlledPromise()\n\n    return reader.read().then(({ done, value }) => {\n      if (done) {\n        streamState.promises[index]!.resolve(null)\n        reader.releaseLock()\n        return\n      }\n\n      streamState.promises[index]!.resolve(value)\n\n      return read(index + 1)\n    })\n  }\n\n  read(0).catch((err: any) => {\n    console.error('stream read error', err)\n  })\n\n  return streamState\n}\n\nfunction StreamChunks({\n  streamState,\n  children,\n  __index = 0,\n}: {\n  streamState: StreamState\n  children: (chunk: string | null) => JSX.Element\n  __index?: number\n}) {\n  const promise = streamState.promises[__index]\n\n  if (!promise) {\n    return null\n  }\n\n  if (promise.status === 'pending') {\n    throw promise\n  }\n\n  const chunk = promise.value!\n\n  return (\n    <>\n      {children(chunk)}\n      <div className=\"tsr-once\">\n        <React.Suspense fallback={null}>\n          <StreamChunks\n            streamState={streamState}\n            __index={__index + 1}\n            children={children}\n          />\n        </React.Suspense>\n      </div>\n    </>\n  )\n}\n\nfunction deepImmutableSetByPath<T>(obj: T, path: Array<string>, value: any): T {\n  // immutable set by path retaining array and object references\n  if (path.length === 0) {\n    return value\n  }\n\n  const [key, ...rest] = path\n\n  if (Array.isArray(obj)) {\n    return obj.map((item, i) => {\n      if (i === Number(key)) {\n        return deepImmutableSetByPath(item, rest, value)\n      }\n      return item\n    }) as T\n  }\n\n  if (isPlainObject(obj)) {\n    return {\n      ...obj,\n      [key!]: deepImmutableSetByPath((obj as any)[key!], rest, value),\n    }\n  }\n\n  return obj\n}\n\nfunction deepMutableSetByPath<T>(obj: T, path: Array<string>, value: any) {\n  // mutable set by path retaining array and object references\n  if (path.length === 1) {\n    ;(obj as any)[path[0]!] = value\n  }\n\n  const [key, ...rest] = path\n\n  if (Array.isArray(obj)) {\n    deepMutableSetByPath(obj[Number(key)], rest, value)\n  } else if (isPlainObject(obj)) {\n    deepMutableSetByPath((obj as any)[key!], rest, value)\n  }\n}\n", "import { RouterProvider } from '@tanstack/react-router'\nimport { afterHydrate } from './serialization'\nimport type { AnyRouter } from '@tanstack/react-router'\n\nlet cleaned = false\n\nexport function StartClient(props: { router: AnyRouter }) {\n  if (!props.router.state.matches.length) {\n    props.router.hydrate()\n    afterHydrate({ router: props.router })\n  }\n\n  if (!cleaned) {\n    cleaned = true\n    window.__TSR__?.cleanScripts()\n  }\n\n  return <RouterProvider router={props.router} />\n}\n", "// TODO: RSCs\n// // @ts-expect-error\n// import * as reactDom from '@vinxi/react-server-dom/client'\nimport { isValidElement } from 'react'\nimport invariant from 'tiny-invariant'\n\nexport function renderRsc(input: any): JSX.Element {\n  if (isValidElement(input)) {\n    return input\n  }\n\n  if (typeof input === 'object' && !input.state) {\n    input.state = {\n      status: 'pending',\n      promise: Promise.resolve()\n        .then(() => {\n          let element\n\n          // We're in node\n          // TODO: RSCs\n          // if (reactDom.createFromNodeStream) {\n          //   const stream = await import('node:stream')\n\n          //   let body: any = input\n\n          //   // Unwrap the response\n          //   if (input instanceof Response) {\n          //     body = input.body\n          //   }\n\n          //   // Convert ReadableStream to NodeJS stream.Readable\n          //   if (body instanceof ReadableStream) {\n          //     body = stream.Readable.fromWeb(body as any)\n          //   }\n\n          //   if (stream.Readable.isReadable(body)) {\n          //     // body = copyStreamToRaw(body)\n          //   } else if (input.text) {\n          //     // create a readable stream by awaiting the text method\n          //     body = new stream.Readable({\n          //       async read() {\n          //         input.text().then((value: any) => {\n          //           this.push(value)\n          //           this.push(null)\n          //         })\n          //       },\n          //     })\n          //   } else {\n          //     console.error('input', input)\n          //     throw new Error('Unexpected rsc input type 👆')\n          //   }\n\n          //   element = await reactDom.createFromNodeStream(body)\n          // } else {\n          //   // We're in the browser\n          //   if (input.body instanceof ReadableStream) {\n          //     input = input.body\n          //   }\n\n          //   if (input instanceof ReadableStream) {\n          //     element = await reactDom.createFromReadableStream(input)\n          //   }\n\n          //   if (input instanceof Response) {\n          //     // copy to the response body to cache the raw data\n          //     element = await reactDom.createFromFetch(input)\n          //   }\n          // }\n\n          // return element\n\n          invariant(false, 'renderRSC() is coming soon!')\n        })\n        .then((element) => {\n          input.state.value = element\n          input.state.status = 'success'\n        })\n        .catch((err) => {\n          input.state.status = 'error'\n          input.state.error = err\n        }),\n    }\n  }\n\n  if (input.state.status === 'pending') {\n    throw input.state.promise\n  }\n\n  return input.state.value\n}\n", "import { isRedirect, useRouter } from '@tanstack/react-router'\n\nexport function useServerFn<T extends (...deps: Array<any>) => Promise<any>>(\n  serverFn: T,\n): (...args: Parameters<T>) => ReturnType<T> {\n  const router = useRouter()\n\n  return (async (...args: Array<any>) => {\n    try {\n      const res = await serverFn(...args)\n\n      if (isRedirect(res)) {\n        throw res\n      }\n\n      return res\n    } catch (err) {\n      if (isRedirect(err)) {\n        router.navigate(\n          router.resolveRedirect({\n            ...err,\n            _fromLocation: router.state.location,\n          }),\n        )\n      }\n\n      throw err\n    }\n  }) as any\n}\n"],
  "mappings": "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",
  "names": ["context", "context", "preloadMeta", "jsesc", "assetScripts"]
}
