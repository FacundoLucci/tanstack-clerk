import invariant from "tiny-invariant";
import { defaultTransformer } from "@tanstack/react-router";
import { mergeHeaders } from "./headers.js";
function createServerFn(options, __opts) {
  const resolvedOptions = __opts || options || {};
  if (typeof resolvedOptions.method === "undefined") {
    resolvedOptions.method = "GET";
  }
  return {
    options: resolvedOptions,
    middleware: (middleware) => {
      return createServerFn(
        void 0,
        Object.assign(resolvedOptions, { middleware })
      );
    },
    validator: (validator) => {
      return createServerFn(
        void 0,
        Object.assign(resolvedOptions, { validator })
      );
    },
    handler: (...args) => {
      const [extractedFn, serverFn] = args;
      Object.assign(resolvedOptions, {
        ...extractedFn,
        extractedFn,
        serverFn
      });
      invariant(
        extractedFn.url,
        `createServerFn must be called with a function that is marked with the 'use server' pragma. Are you using the @tanstack/start-vite-plugin ?`
      );
      const resolvedMiddleware = [
        ...resolvedOptions.middleware || [],
        serverFnBaseToMiddleware(resolvedOptions)
      ];
      return Object.assign(
        async (opts) => {
          return executeMiddleware(resolvedMiddleware, "client", {
            ...extractedFn,
            method: resolvedOptions.method,
            data: opts == null ? void 0 : opts.data,
            headers: opts == null ? void 0 : opts.headers,
            context: Object.assign({}, extractedFn)
          }).then((d) => d.result);
        },
        {
          // This copies over the URL, function ID and filename
          ...extractedFn,
          // The extracted function on the server-side calls
          // this function
          __executeServer: (opts) => {
            const parsedOpts = opts instanceof FormData ? extractFormDataContext(opts) : opts;
            return executeMiddleware(resolvedMiddleware, "server", {
              ...extractedFn,
              ...parsedOpts
            }).then((d) => ({
              // Only send the result and sendContext back to the client
              result: d.result,
              context: d.sendContext
            }));
          }
        }
      );
    }
  };
}
function extractFormDataContext(formData) {
  const serializedContext = formData.get("__TSR_CONTEXT");
  formData.delete("__TSR_CONTEXT");
  if (typeof serializedContext !== "string") {
    return {
      context: {},
      data: formData
    };
  }
  try {
    const context = defaultTransformer.parse(serializedContext);
    return {
      context,
      data: formData
    };
  } catch (e) {
    return {
      data: formData
    };
  }
}
function flattenMiddlewares(middlewares) {
  const flattened = [];
  const recurse = (middleware) => {
    middleware.forEach((m) => {
      if (m.options.middleware) {
        recurse(m.options.middleware);
      }
      flattened.push(m);
    });
  };
  recurse(middlewares);
  return flattened;
}
const applyMiddleware = (middlewareFn, mCtx, nextFn) => {
  return middlewareFn({
    data: mCtx.data,
    context: mCtx.context,
    sendContext: mCtx.sendContext,
    method: mCtx.method,
    next: (userResult) => {
      const context = {
        ...mCtx.context,
        ...userResult == null ? void 0 : userResult.context
      };
      const sendContext = {
        ...mCtx.sendContext,
        ...(userResult == null ? void 0 : userResult.sendContext) ?? {}
      };
      const headers = mergeHeaders(mCtx.headers, userResult == null ? void 0 : userResult.headers);
      return nextFn({
        method: mCtx.method,
        data: mCtx.data,
        context,
        sendContext,
        headers,
        result: (userResult == null ? void 0 : userResult.result) ?? mCtx.result
      });
    }
  });
};
function execValidator(validator, input) {
  if (validator == null) return {};
  if ("~standard" in validator) {
    const result = validator["~standard"].validate(input);
    if ("value" in result) return result.value;
    if (result instanceof Promise)
      throw new Error("Async validation not supported");
    throw new Error(JSON.stringify(result.issues, void 0, 2));
  }
  if ("parse" in validator) {
    return validator.parse(input);
  }
  if (typeof validator === "function") {
    return validator(input);
  }
  throw new Error("Invalid validator type!");
}
async function executeMiddleware(middlewares, env, opts) {
  const flattenedMiddlewares = flattenMiddlewares(middlewares);
  const next = async (ctx) => {
    const nextMiddleware = flattenedMiddlewares.shift();
    if (!nextMiddleware) {
      return ctx;
    }
    if (nextMiddleware.options.validator && (env === "client" ? nextMiddleware.options.validateClient : true)) {
      ctx.data = await execValidator(nextMiddleware.options.validator, ctx.data);
    }
    const middlewareFn = env === "client" ? nextMiddleware.options.client : nextMiddleware.options.server;
    if (middlewareFn) {
      return applyMiddleware(
        middlewareFn,
        ctx,
        async (userCtx) => {
          if (env === "client" && nextMiddleware.options.clientAfter) {
            const result = await next(userCtx);
            return applyMiddleware(
              nextMiddleware.options.clientAfter,
              result,
              // Identity, because there "next" is just returning
              (d) => d
            );
          }
          return next(userCtx);
        }
      );
    }
    return next(ctx);
  };
  return next({
    ...opts,
    headers: opts.headers || {},
    sendContext: opts.sendContext || {},
    context: opts.context || {}
  });
}
function serverFnBaseToMiddleware(options) {
  return {
    _types: void 0,
    options: {
      validator: options.validator,
      validateClient: options.validateClient,
      client: async ({ next, sendContext, ...ctx }) => {
        var _a;
        const res = await ((_a = options.extractedFn) == null ? void 0 : _a.call(options, {
          ...ctx,
          // switch the sendContext over to context
          context: sendContext
        }));
        return next(res);
      },
      server: async ({ next, ...ctx }) => {
        var _a;
        const result = await ((_a = options.serverFn) == null ? void 0 : _a.call(options, ctx));
        return next({
          result
        });
      }
    }
  };
}
export {
  createServerFn
};
//# sourceMappingURL=createServerFn.js.map
