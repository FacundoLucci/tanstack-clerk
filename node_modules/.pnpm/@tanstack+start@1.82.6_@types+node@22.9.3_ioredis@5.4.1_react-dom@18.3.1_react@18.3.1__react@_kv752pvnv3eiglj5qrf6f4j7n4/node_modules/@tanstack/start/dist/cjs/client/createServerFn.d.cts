import { Constrain, DefaultTransformerParse, DefaultTransformerStringify, ResolveValidatorInput, Validator } from '@tanstack/react-router';
import { AnyMiddleware, MergeAllServerContext, MergeAllValidatorInputs, MergeAllValidatorOutputs, ResolveAllValidators } from './createMiddleware.cjs';
export interface JsonResponse<TData> extends Response {
    json: () => Promise<TData>;
}
export type CompiledFetcherFnOptions = {
    method: Method;
    data: unknown;
    headers?: HeadersInit;
};
export type Fetcher<TMiddlewares, TValidator, TResponse> = {
    url: string;
    __executeServer: (opts: {
        method: Method;
        data: unknown;
        headers?: HeadersInit;
    }) => Promise<unknown>;
} & FetcherImpl<TMiddlewares, TValidator, TResponse>;
export type IsDataOptional<TMiddlewares, TValidator> = ResolveAllValidators<TMiddlewares, TValidator>;
export type FetcherImpl<TMiddlewares, TValidator, TResponse> = undefined extends MergeAllValidatorInputs<TMiddlewares, TValidator> ? (opts?: OptionalFetcherDataOptions<MergeAllValidatorInputs<TMiddlewares, TValidator>>) => Promise<FetcherData<TResponse>> : (opts: RequiredFetcherDataOptions<MergeAllValidatorInputs<TMiddlewares, TValidator>>) => Promise<FetcherData<TResponse>>;
export type FetcherBaseOptions = {
    headers?: HeadersInit;
};
export interface RequiredFetcherDataOptions<TInput> extends FetcherBaseOptions {
    data: TInput;
}
export interface OptionalFetcherDataOptions<TInput> extends FetcherBaseOptions {
    data?: TInput;
}
export type FetcherData<TResponse> = DefaultTransformerParse<TResponse extends JsonResponse<infer TData> ? TData : TResponse>;
export type RscStream<T> = {
    __cacheState: T;
};
export type Method = 'GET' | 'POST';
export type ServerFn<TMethod, TMiddlewares, TValidator, TResponse> = (ctx: ServerFnCtx<TMethod, TMiddlewares, TValidator>) => Promise<DefaultTransformerStringify<TResponse>> | DefaultTransformerStringify<TResponse>;
export type ServerFnCtx<TMethod, TMiddlewares, TValidator> = {
    method: TMethod;
    data: MergeAllValidatorOutputs<TMiddlewares, TValidator>;
    context: MergeAllServerContext<TMiddlewares>;
};
export type CompiledFetcherFn<TResponse> = {
    (opts: CompiledFetcherFnOptions & ServerFnBaseOptions): Promise<TResponse>;
    url: string;
};
type ServerFnBaseOptions<TMethod extends Method = 'GET', TResponse = unknown, TMiddlewares = unknown, TInput = unknown> = {
    method: TMethod;
    validateClient?: boolean;
    middleware?: Constrain<TMiddlewares, ReadonlyArray<AnyMiddleware>>;
    validator?: ConstrainValidator<TInput>;
    extractedFn?: CompiledFetcherFn<TResponse>;
    serverFn?: ServerFn<TMethod, TMiddlewares, TInput, TResponse>;
    filename: string;
    functionId: string;
};
export type ConstrainValidator<TValidator> = unknown extends TValidator ? TValidator : Constrain<TValidator, Validator<DefaultTransformerStringify<ResolveValidatorInput<TValidator>>, any>>;
type ServerFnBase<TMethod extends Method = 'GET', TResponse = unknown, TMiddlewares = unknown, TValidator = unknown> = {
    options: ServerFnBaseOptions<TMethod, TResponse, TMiddlewares, TValidator>;
    middleware: <const TNewMiddlewares>(middlewares: Constrain<TNewMiddlewares, ReadonlyArray<AnyMiddleware>>) => Pick<ServerFnBase<TMethod, TResponse, TNewMiddlewares, TValidator>, 'validator' | 'handler'>;
    validator: <TValidator>(validator: ConstrainValidator<TValidator>) => Pick<ServerFnBase<TMethod, TResponse, TMiddlewares, TValidator>, 'handler' | 'middleware'>;
    handler: <TNewResponse>(fn?: ServerFn<TMethod, TMiddlewares, TValidator, TNewResponse>) => Fetcher<TMiddlewares, TValidator, TNewResponse>;
};
export declare function createServerFn<TMethod extends Method, TResponse = unknown, TMiddlewares = undefined, TValidator = undefined>(options?: {
    method: TMethod;
}, __opts?: ServerFnBaseOptions<TMethod, TResponse, TMiddlewares, TValidator>): ServerFnBase<TMethod, TResponse, TMiddlewares, TValidator>;
export type MiddlewareOptions = {
    method: Method;
    data: any;
    headers?: HeadersInit;
    sendContext?: any;
    context?: any;
};
export type MiddlewareResult = {
    context: any;
    sendContext: any;
    data: any;
    result: unknown;
};
export {};
