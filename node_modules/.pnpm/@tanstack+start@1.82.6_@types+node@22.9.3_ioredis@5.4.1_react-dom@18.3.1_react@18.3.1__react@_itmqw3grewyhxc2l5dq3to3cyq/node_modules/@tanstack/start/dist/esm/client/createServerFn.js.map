{"version":3,"file":"createServerFn.js","sources":["../../../src/client/createServerFn.ts"],"sourcesContent":["import invariant from 'tiny-invariant'\nimport { defaultTransformer } from '@tanstack/react-router'\nimport { mergeHeaders } from './headers'\nimport type {\n  AnyValidator,\n  Constrain,\n  DefaultTransformerParse,\n  DefaultTransformerStringify,\n  ResolveValidatorInput,\n  Validator,\n} from '@tanstack/react-router'\nimport type {\n  AnyMiddleware,\n  MergeAllServerContext,\n  MergeAllValidatorInputs,\n  MergeAllValidatorOutputs,\n  ResolveAllValidators,\n} from './createMiddleware'\n\n//\n\nexport interface JsonResponse<TData> extends Response {\n  json: () => Promise<TData>\n}\n\nexport type CompiledFetcherFnOptions = {\n  method: Method\n  data: unknown\n  headers?: HeadersInit\n}\n\nexport type Fetcher<TMiddlewares, TValidator, TResponse> = {\n  url: string\n  __executeServer: (opts: {\n    method: Method\n    data: unknown\n    headers?: HeadersInit\n  }) => Promise<unknown>\n} & FetcherImpl<TMiddlewares, TValidator, TResponse>\n\nexport type IsDataOptional<TMiddlewares, TValidator> = ResolveAllValidators<\n  TMiddlewares,\n  TValidator\n>\n\nexport type FetcherImpl<TMiddlewares, TValidator, TResponse> =\n  undefined extends MergeAllValidatorInputs<TMiddlewares, TValidator>\n    ? (\n        opts?: OptionalFetcherDataOptions<\n          MergeAllValidatorInputs<TMiddlewares, TValidator>\n        >,\n      ) => Promise<FetcherData<TResponse>>\n    : (\n        opts: RequiredFetcherDataOptions<\n          MergeAllValidatorInputs<TMiddlewares, TValidator>\n        >,\n      ) => Promise<FetcherData<TResponse>>\n\nexport type FetcherBaseOptions = {\n  headers?: HeadersInit\n}\n\nexport interface RequiredFetcherDataOptions<TInput> extends FetcherBaseOptions {\n  data: TInput\n}\n\nexport interface OptionalFetcherDataOptions<TInput> extends FetcherBaseOptions {\n  data?: TInput\n}\n\nexport type FetcherData<TResponse> = DefaultTransformerParse<\n  TResponse extends JsonResponse<infer TData> ? TData : TResponse\n>\n\nexport type RscStream<T> = {\n  __cacheState: T\n}\n\nexport type Method = 'GET' | 'POST'\n\nexport type ServerFn<TMethod, TMiddlewares, TValidator, TResponse> = (\n  ctx: ServerFnCtx<TMethod, TMiddlewares, TValidator>,\n) =>\n  | Promise<DefaultTransformerStringify<TResponse>>\n  | DefaultTransformerStringify<TResponse>\n\nexport type ServerFnCtx<TMethod, TMiddlewares, TValidator> = {\n  method: TMethod\n  data: MergeAllValidatorOutputs<TMiddlewares, TValidator>\n  context: MergeAllServerContext<TMiddlewares>\n}\n\nexport type CompiledFetcherFn<TResponse> = {\n  (opts: CompiledFetcherFnOptions & ServerFnBaseOptions): Promise<TResponse>\n  url: string\n}\n\ntype ServerFnBaseOptions<\n  TMethod extends Method = 'GET',\n  TResponse = unknown,\n  TMiddlewares = unknown,\n  TInput = unknown,\n> = {\n  method: TMethod\n  validateClient?: boolean\n  middleware?: Constrain<TMiddlewares, ReadonlyArray<AnyMiddleware>>\n  validator?: ConstrainValidator<TInput>\n  extractedFn?: CompiledFetcherFn<TResponse>\n  serverFn?: ServerFn<TMethod, TMiddlewares, TInput, TResponse>\n  filename: string\n  functionId: string\n}\n\nexport type ConstrainValidator<TValidator> = unknown extends TValidator\n  ? TValidator\n  : Constrain<\n      TValidator,\n      Validator<\n        DefaultTransformerStringify<ResolveValidatorInput<TValidator>>,\n        any\n      >\n    >\n\ntype ServerFnBase<\n  TMethod extends Method = 'GET',\n  TResponse = unknown,\n  TMiddlewares = unknown,\n  TValidator = unknown,\n> = {\n  options: ServerFnBaseOptions<TMethod, TResponse, TMiddlewares, TValidator>\n  middleware: <const TNewMiddlewares>(\n    middlewares: Constrain<TNewMiddlewares, ReadonlyArray<AnyMiddleware>>,\n  ) => Pick<\n    ServerFnBase<TMethod, TResponse, TNewMiddlewares, TValidator>,\n    'validator' | 'handler'\n  >\n  validator: <TValidator>(\n    validator: ConstrainValidator<TValidator>,\n  ) => Pick<\n    ServerFnBase<TMethod, TResponse, TMiddlewares, TValidator>,\n    'handler' | 'middleware'\n  >\n  handler: <TNewResponse>(\n    fn?: ServerFn<TMethod, TMiddlewares, TValidator, TNewResponse>,\n  ) => Fetcher<TMiddlewares, TValidator, TNewResponse>\n}\n\nexport function createServerFn<\n  TMethod extends Method,\n  TResponse = unknown,\n  TMiddlewares = undefined,\n  TValidator = undefined,\n>(\n  options?: {\n    method: TMethod\n  },\n  __opts?: ServerFnBaseOptions<TMethod, TResponse, TMiddlewares, TValidator>,\n): ServerFnBase<TMethod, TResponse, TMiddlewares, TValidator> {\n  const resolvedOptions = (__opts || options || {}) as ServerFnBaseOptions<\n    TMethod,\n    TResponse,\n    TMiddlewares,\n    TValidator\n  >\n\n  if (typeof resolvedOptions.method === 'undefined') {\n    resolvedOptions.method = 'GET' as TMethod\n  }\n\n  return {\n    options: resolvedOptions as any,\n    middleware: (middleware) => {\n      return createServerFn<TMethod, TResponse, TMiddlewares, TValidator>(\n        undefined,\n        Object.assign(resolvedOptions, { middleware }),\n      ) as any\n    },\n    validator: (validator) => {\n      return createServerFn<TMethod, TResponse, TMiddlewares, TValidator>(\n        undefined,\n        Object.assign(resolvedOptions, { validator }),\n      ) as any\n    },\n    handler: (...args) => {\n      // This function signature changes due to AST transformations\n      // in the babel plugin. We need to cast it to the correct\n      // function signature post-transformation\n      const [extractedFn, serverFn] = args as unknown as [\n        CompiledFetcherFn<TResponse>,\n        ServerFn<TMethod, TMiddlewares, TValidator, TResponse>,\n      ]\n\n      // Keep the original function around so we can use it\n      // in the server environment\n      Object.assign(resolvedOptions, {\n        ...extractedFn,\n        extractedFn,\n        serverFn,\n      })\n\n      invariant(\n        extractedFn.url,\n        `createServerFn must be called with a function that is marked with the 'use server' pragma. Are you using the @tanstack/start-vite-plugin ?`,\n      )\n\n      const resolvedMiddleware = [\n        ...(resolvedOptions.middleware || []),\n        serverFnBaseToMiddleware(resolvedOptions),\n      ]\n\n      // We want to make sure the new function has the same\n      // properties as the original function\n      return Object.assign(\n        async (opts?: CompiledFetcherFnOptions) => {\n          // Start by executing the client-side middleware chain\n          return executeMiddleware(resolvedMiddleware, 'client', {\n            ...extractedFn,\n            method: resolvedOptions.method,\n            data: opts?.data as any,\n            headers: opts?.headers,\n            context: Object.assign({}, extractedFn),\n          }).then((d) => d.result)\n        },\n        {\n          // This copies over the URL, function ID and filename\n          ...extractedFn,\n          // The extracted function on the server-side calls\n          // this function\n          __executeServer: (opts: any) => {\n            const parsedOpts =\n              opts instanceof FormData ? extractFormDataContext(opts) : opts\n\n            return executeMiddleware(resolvedMiddleware, 'server', {\n              ...extractedFn,\n              ...parsedOpts,\n            }).then((d) => ({\n              // Only send the result and sendContext back to the client\n              result: d.result,\n              context: d.sendContext,\n            }))\n          },\n        },\n      ) as any\n    },\n  }\n}\n\nfunction extractFormDataContext(formData: FormData) {\n  const serializedContext = formData.get('__TSR_CONTEXT')\n  formData.delete('__TSR_CONTEXT')\n\n  if (typeof serializedContext !== 'string') {\n    return {\n      context: {},\n      data: formData,\n    }\n  }\n\n  try {\n    const context = defaultTransformer.parse(serializedContext)\n    return {\n      context,\n      data: formData,\n    }\n  } catch (e) {\n    return {\n      data: formData,\n    }\n  }\n}\n\nfunction flattenMiddlewares(\n  middlewares: Array<AnyMiddleware>,\n): Array<AnyMiddleware> {\n  const flattened: Array<AnyMiddleware> = []\n\n  const recurse = (middleware: Array<AnyMiddleware>) => {\n    middleware.forEach((m) => {\n      if (m.options.middleware) {\n        recurse(m.options.middleware)\n      }\n      flattened.push(m)\n    })\n  }\n\n  recurse(middlewares)\n\n  return flattened\n}\n\nexport type MiddlewareOptions = {\n  method: Method\n  data: any\n  headers?: HeadersInit\n  sendContext?: any\n  context?: any\n}\n\nexport type MiddlewareResult = {\n  context: any\n  sendContext: any\n  data: any\n  result: unknown\n}\n\nconst applyMiddleware = (\n  middlewareFn: NonNullable<\n    | AnyMiddleware['options']['client']\n    | AnyMiddleware['options']['server']\n    | AnyMiddleware['options']['clientAfter']\n  >,\n  mCtx: MiddlewareOptions,\n  nextFn: (ctx: MiddlewareOptions) => Promise<MiddlewareResult>,\n) => {\n  return middlewareFn({\n    data: mCtx.data,\n    context: mCtx.context,\n    sendContext: mCtx.sendContext,\n    method: mCtx.method,\n    next: ((userResult: any) => {\n      // Take the user provided context\n      // and merge it with the current context\n      const context = {\n        ...mCtx.context,\n        ...userResult?.context,\n      }\n\n      const sendContext = {\n        ...mCtx.sendContext,\n        ...(userResult?.sendContext ?? {}),\n      }\n\n      const headers = mergeHeaders(mCtx.headers, userResult?.headers)\n\n      // Return the next middleware\n      return nextFn({\n        method: mCtx.method,\n        data: mCtx.data,\n        context,\n        sendContext,\n        headers,\n        result: userResult?.result ?? (mCtx as any).result,\n      } as MiddlewareResult & {\n        method: Method\n      })\n    }) as any,\n  })\n}\n\nfunction execValidator(validator: AnyValidator, input: unknown): unknown {\n  if (validator == null) return {}\n\n  if ('~standard' in validator) {\n    const result = validator['~standard'].validate(input)\n\n    if ('value' in result) return result.value\n\n    if (result instanceof Promise)\n      throw new Error('Async validation not supported')\n\n    throw new Error(JSON.stringify(result.issues, undefined, 2))\n  }\n\n  if ('parse' in validator) {\n    return validator.parse(input)\n  }\n\n  if (typeof validator === 'function') {\n    return validator(input)\n  }\n\n  throw new Error('Invalid validator type!')\n}\n\nasync function executeMiddleware(\n  middlewares: Array<AnyMiddleware>,\n  env: 'client' | 'server',\n  opts: MiddlewareOptions,\n): Promise<MiddlewareResult> {\n  const flattenedMiddlewares = flattenMiddlewares(middlewares)\n\n  const next = async (ctx: MiddlewareOptions): Promise<MiddlewareResult> => {\n    // Get the next middleware\n    const nextMiddleware = flattenedMiddlewares.shift()\n\n    // If there are no more middlewares, return the context\n    if (!nextMiddleware) {\n      return ctx as any\n    }\n\n    if (\n      nextMiddleware.options.validator &&\n      (env === 'client' ? nextMiddleware.options.validateClient : true)\n    ) {\n      // Execute the middleware's input function\n      ctx.data = await execValidator(nextMiddleware.options.validator, ctx.data)\n    }\n\n    const middlewareFn =\n      env === 'client'\n        ? nextMiddleware.options.client\n        : nextMiddleware.options.server\n\n    if (middlewareFn) {\n      // Execute the middleware\n      return applyMiddleware(\n        middlewareFn,\n        ctx,\n        async (userCtx): Promise<MiddlewareResult> => {\n          // If there is a clientAfter function and we are on the client\n          if (env === 'client' && nextMiddleware.options.clientAfter) {\n            // We need to await the next middleware and get the result\n            const result = await next(userCtx)\n            // Then we can execute the clientAfter function\n            return applyMiddleware(\n              nextMiddleware.options.clientAfter,\n              result as any,\n              // Identity, because there \"next\" is just returning\n              (d: any) => d,\n            ) as any\n          }\n\n          return next(userCtx)\n        },\n      ) as any\n    }\n\n    return next(ctx)\n  }\n\n  // Start the middleware chain\n  return next({\n    ...opts,\n    headers: opts.headers || {},\n    sendContext: (opts as any).sendContext || {},\n    context: opts.context || {},\n  })\n}\n\nfunction serverFnBaseToMiddleware(\n  options: ServerFnBaseOptions<any, any, any, any>,\n): AnyMiddleware {\n  return {\n    _types: undefined!,\n    options: {\n      validator: options.validator,\n      validateClient: options.validateClient,\n      client: async ({ next, sendContext, ...ctx }) => {\n        // Execute the extracted function\n        // but not before serializing the context\n        const res = await options.extractedFn?.({\n          ...ctx,\n          // switch the sendContext over to context\n          context: sendContext,\n        } as any)\n\n        return next(res)\n      },\n      server: async ({ next, ...ctx }) => {\n        // Execute the server function\n        const result = await options.serverFn?.(ctx as any)\n\n        return next({\n          result,\n        } as any)\n      },\n    },\n  }\n}\n"],"names":[],"mappings":";;;AAmJgB,SAAA,eAMd,SAGA,QAC4D;AACtD,QAAA,kBAAmB,UAAU,WAAW,CAAC;AAO3C,MAAA,OAAO,gBAAgB,WAAW,aAAa;AACjD,oBAAgB,SAAS;AAAA,EAAA;AAGpB,SAAA;AAAA,IACL,SAAS;AAAA,IACT,YAAY,CAAC,eAAe;AACnB,aAAA;AAAA,QACL;AAAA,QACA,OAAO,OAAO,iBAAiB,EAAE,WAAY,CAAA;AAAA,MAC/C;AAAA,IACF;AAAA,IACA,WAAW,CAAC,cAAc;AACjB,aAAA;AAAA,QACL;AAAA,QACA,OAAO,OAAO,iBAAiB,EAAE,UAAW,CAAA;AAAA,MAC9C;AAAA,IACF;AAAA,IACA,SAAS,IAAI,SAAS;AAId,YAAA,CAAC,aAAa,QAAQ,IAAI;AAOhC,aAAO,OAAO,iBAAiB;AAAA,QAC7B,GAAG;AAAA,QACH;AAAA,QACA;AAAA,MAAA,CACD;AAED;AAAA,QACE,YAAY;AAAA,QACZ;AAAA,MACF;AAEA,YAAM,qBAAqB;AAAA,QACzB,GAAI,gBAAgB,cAAc,CAAC;AAAA,QACnC,yBAAyB,eAAe;AAAA,MAC1C;AAIA,aAAO,OAAO;AAAA,QACZ,OAAO,SAAoC;AAElC,iBAAA,kBAAkB,oBAAoB,UAAU;AAAA,YACrD,GAAG;AAAA,YACH,QAAQ,gBAAgB;AAAA,YACxB,MAAM,6BAAM;AAAA,YACZ,SAAS,6BAAM;AAAA,YACf,SAAS,OAAO,OAAO,CAAA,GAAI,WAAW;AAAA,UACvC,CAAA,EAAE,KAAK,CAAC,MAAM,EAAE,MAAM;AAAA,QACzB;AAAA,QACA;AAAA;AAAA,UAEE,GAAG;AAAA;AAAA;AAAA,UAGH,iBAAiB,CAAC,SAAc;AAC9B,kBAAM,aACJ,gBAAgB,WAAW,uBAAuB,IAAI,IAAI;AAErD,mBAAA,kBAAkB,oBAAoB,UAAU;AAAA,cACrD,GAAG;AAAA,cACH,GAAG;AAAA,YAAA,CACJ,EAAE,KAAK,CAAC,OAAO;AAAA;AAAA,cAEd,QAAQ,EAAE;AAAA,cACV,SAAS,EAAE;AAAA,YAAA,EACX;AAAA,UAAA;AAAA,QACJ;AAAA,MAEJ;AAAA,IAAA;AAAA,EAEJ;AACF;AAEA,SAAS,uBAAuB,UAAoB;AAC5C,QAAA,oBAAoB,SAAS,IAAI,eAAe;AACtD,WAAS,OAAO,eAAe;AAE3B,MAAA,OAAO,sBAAsB,UAAU;AAClC,WAAA;AAAA,MACL,SAAS,CAAC;AAAA,MACV,MAAM;AAAA,IACR;AAAA,EAAA;AAGE,MAAA;AACI,UAAA,UAAU,mBAAmB,MAAM,iBAAiB;AACnD,WAAA;AAAA,MACL;AAAA,MACA,MAAM;AAAA,IACR;AAAA,WACO,GAAG;AACH,WAAA;AAAA,MACL,MAAM;AAAA,IACR;AAAA,EAAA;AAEJ;AAEA,SAAS,mBACP,aACsB;AACtB,QAAM,YAAkC,CAAC;AAEnC,QAAA,UAAU,CAAC,eAAqC;AACzC,eAAA,QAAQ,CAAC,MAAM;AACpB,UAAA,EAAE,QAAQ,YAAY;AAChB,gBAAA,EAAE,QAAQ,UAAU;AAAA,MAAA;AAE9B,gBAAU,KAAK,CAAC;AAAA,IAAA,CACjB;AAAA,EACH;AAEA,UAAQ,WAAW;AAEZ,SAAA;AACT;AAiBA,MAAM,kBAAkB,CACtB,cAKA,MACA,WACG;AACH,SAAO,aAAa;AAAA,IAClB,MAAM,KAAK;AAAA,IACX,SAAS,KAAK;AAAA,IACd,aAAa,KAAK;AAAA,IAClB,QAAQ,KAAK;AAAA,IACb,MAAO,CAAC,eAAoB;AAG1B,YAAM,UAAU;AAAA,QACd,GAAG,KAAK;AAAA,QACR,GAAG,yCAAY;AAAA,MACjB;AAEA,YAAM,cAAc;AAAA,QAClB,GAAG,KAAK;AAAA,QACR,IAAI,yCAAY,gBAAe,CAAA;AAAA,MACjC;AAEA,YAAM,UAAU,aAAa,KAAK,SAAS,yCAAY,OAAO;AAG9D,aAAO,OAAO;AAAA,QACZ,QAAQ,KAAK;AAAA,QACb,MAAM,KAAK;AAAA,QACX;AAAA,QACA;AAAA,QACA;AAAA,QACA,SAAQ,yCAAY,WAAW,KAAa;AAAA,MAAA,CAG7C;AAAA,IAAA;AAAA,EACH,CACD;AACH;AAEA,SAAS,cAAc,WAAyB,OAAyB;AACnE,MAAA,aAAa,KAAM,QAAO,CAAC;AAE/B,MAAI,eAAe,WAAW;AAC5B,UAAM,SAAS,UAAU,WAAW,EAAE,SAAS,KAAK;AAEhD,QAAA,WAAW,OAAQ,QAAO,OAAO;AAErC,QAAI,kBAAkB;AACd,YAAA,IAAI,MAAM,gCAAgC;AAE5C,UAAA,IAAI,MAAM,KAAK,UAAU,OAAO,QAAQ,QAAW,CAAC,CAAC;AAAA,EAAA;AAG7D,MAAI,WAAW,WAAW;AACjB,WAAA,UAAU,MAAM,KAAK;AAAA,EAAA;AAG1B,MAAA,OAAO,cAAc,YAAY;AACnC,WAAO,UAAU,KAAK;AAAA,EAAA;AAGlB,QAAA,IAAI,MAAM,yBAAyB;AAC3C;AAEA,eAAe,kBACb,aACA,KACA,MAC2B;AACrB,QAAA,uBAAuB,mBAAmB,WAAW;AAErD,QAAA,OAAO,OAAO,QAAsD;AAElE,UAAA,iBAAiB,qBAAqB,MAAM;AAGlD,QAAI,CAAC,gBAAgB;AACZ,aAAA;AAAA,IAAA;AAIP,QAAA,eAAe,QAAQ,cACtB,QAAQ,WAAW,eAAe,QAAQ,iBAAiB,OAC5D;AAEA,UAAI,OAAO,MAAM,cAAc,eAAe,QAAQ,WAAW,IAAI,IAAI;AAAA,IAAA;AAG3E,UAAM,eACJ,QAAQ,WACJ,eAAe,QAAQ,SACvB,eAAe,QAAQ;AAE7B,QAAI,cAAc;AAET,aAAA;AAAA,QACL;AAAA,QACA;AAAA,QACA,OAAO,YAAuC;AAE5C,cAAI,QAAQ,YAAY,eAAe,QAAQ,aAAa;AAEpD,kBAAA,SAAS,MAAM,KAAK,OAAO;AAE1B,mBAAA;AAAA,cACL,eAAe,QAAQ;AAAA,cACvB;AAAA;AAAA,cAEA,CAAC,MAAW;AAAA,YACd;AAAA,UAAA;AAGF,iBAAO,KAAK,OAAO;AAAA,QAAA;AAAA,MAEvB;AAAA,IAAA;AAGF,WAAO,KAAK,GAAG;AAAA,EACjB;AAGA,SAAO,KAAK;AAAA,IACV,GAAG;AAAA,IACH,SAAS,KAAK,WAAW,CAAC;AAAA,IAC1B,aAAc,KAAa,eAAe,CAAC;AAAA,IAC3C,SAAS,KAAK,WAAW,CAAA;AAAA,EAAC,CAC3B;AACH;AAEA,SAAS,yBACP,SACe;AACR,SAAA;AAAA,IACL,QAAQ;AAAA,IACR,SAAS;AAAA,MACP,WAAW,QAAQ;AAAA,MACnB,gBAAgB,QAAQ;AAAA,MACxB,QAAQ,OAAO,EAAE,MAAM,aAAa,GAAG,UAAU;;AAGzC,cAAA,MAAM,QAAM,aAAQ,gBAAR,iCAAsB;AAAA,UACtC,GAAG;AAAA;AAAA,UAEH,SAAS;AAAA,QAAA;AAGX,eAAO,KAAK,GAAG;AAAA,MACjB;AAAA,MACA,QAAQ,OAAO,EAAE,MAAM,GAAG,UAAU;;AAElC,cAAM,SAAS,QAAM,aAAQ,aAAR,iCAAmB;AAExC,eAAO,KAAK;AAAA,UACV;AAAA,QAAA,CACM;AAAA,MAAA;AAAA,IACV;AAAA,EAEJ;AACF;"}