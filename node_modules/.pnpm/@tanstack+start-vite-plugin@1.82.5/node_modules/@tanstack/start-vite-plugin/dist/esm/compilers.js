import * as babel from "@babel/core";
import * as t from "@babel/types";
import _generate from "@babel/generator";
import { codeFrameColumns } from "@babel/code-frame";
import { deadCodeElimination } from "babel-dead-code-elimination";
import { parseAst } from "./ast.js";
let generate = _generate["default"];
if (!generate) {
  generate = _generate;
}
function compileEliminateDeadCode(opts) {
  const ast = parseAst(opts);
  if (!ast) {
    throw new Error(
      `Failed to compile ast for compileEliminateDeadCode() for the file: ${opts.filename}`
    );
  }
  deadCodeElimination(ast);
  return generate(ast, {
    sourceMaps: true
  });
}
const debug = process.env.TSR_VITE_DEBUG === "true";
function compileStartOutput(opts) {
  const ast = parseAst(opts);
  if (!ast) {
    throw new Error(
      `Failed to compile ast for compileStartOutput() for the file: ${opts.filename}`
    );
  }
  babel.traverse(ast, {
    Program: {
      enter(programPath) {
        const identifiers = {
          createServerFn: {
            name: "createServerFn",
            type: "ImportSpecifier",
            namespaceId: "",
            handleCallExpression: handleCreateServerFnCallExpression,
            paths: []
          },
          createMiddleware: {
            name: "createMiddleware",
            type: "ImportSpecifier",
            namespaceId: "",
            handleCallExpression: handleCreateMiddlewareCallExpression,
            paths: []
          },
          serverOnly: {
            name: "serverOnly",
            type: "ImportSpecifier",
            namespaceId: "",
            handleCallExpression: handleServerOnlyCallExpression,
            paths: []
          }
        };
        const identifierKeys = Object.keys(identifiers);
        programPath.traverse({
          ImportDeclaration: (path) => {
            if (path.node.source.value !== "@tanstack/start") {
              return;
            }
            path.node.specifiers.forEach((specifier) => {
              identifierKeys.forEach((identifierKey) => {
                const identifier = identifiers[identifierKey];
                if (specifier.type === "ImportSpecifier" && specifier.imported.type === "Identifier") {
                  if (specifier.imported.name === identifierKey) {
                    identifier.name = specifier.local.name;
                    identifier.type = "ImportSpecifier";
                  }
                }
                if (specifier.type === "ImportNamespaceSpecifier") {
                  identifier.type = "ImportNamespaceSpecifier";
                  identifier.namespaceId = specifier.local.name;
                  identifier.name = `${identifier.namespaceId}.${identifierKey}`;
                }
              });
            });
          },
          CallExpression: (path) => {
            identifierKeys.forEach((identifierKey) => {
              var _a;
              if (t.isIdentifier(path.node.callee) && path.node.callee.name === identifiers[identifierKey].name) {
                if (((_a = path.scope.getBinding(identifiers[identifierKey].name)) == null ? void 0 : _a.path.node.type) === "FunctionDeclaration") {
                  return;
                }
                return identifiers[identifierKey].paths.push(path);
              }
              if (t.isMemberExpression(path.node.callee)) {
                if (t.isIdentifier(path.node.callee.object) && t.isIdentifier(path.node.callee.property)) {
                  const callname = [
                    path.node.callee.object.name,
                    path.node.callee.property.name
                  ].join(".");
                  if (callname === identifiers[identifierKey].name) {
                    identifiers[identifierKey].paths.push(path);
                  }
                }
              }
              return;
            });
          }
        });
        identifierKeys.forEach((identifierKey) => {
          identifiers[identifierKey].paths.forEach((path) => {
            identifiers[identifierKey].handleCallExpression(
              path,
              opts
            );
          });
        });
      }
    }
  });
  return generate(ast, {
    sourceMaps: true,
    minified: process.env.NODE_ENV === "production"
  });
}
function handleCreateServerFnCallExpression(path, opts) {
  var _a;
  const calledOptions = path.node.arguments[0] ? path.get("arguments.0") : null;
  const shouldValidateClient = !!(calledOptions == null ? void 0 : calledOptions.node.properties.find((prop) => {
    return t.isObjectProperty(prop) && t.isIdentifier(prop.key) && prop.key.name === "validateClient" && t.isBooleanLiteral(prop.value) && prop.value.value === true;
  }));
  const callExpressionPaths = {
    middleware: null,
    validator: null,
    handler: null
  };
  const validMethods = Object.keys(callExpressionPaths);
  const rootCallExpression = getRootCallExpression(path);
  if (debug)
    console.info(
      "Handling createServerFn call expression:",
      rootCallExpression.toString()
    );
  if (!rootCallExpression.parentPath.isVariableDeclarator()) {
    throw new Error("createServerFn must be assigned to a variable!");
  }
  const variableDeclarator = rootCallExpression.parentPath.node;
  const existingVariableName = variableDeclarator.id.name;
  rootCallExpression.traverse({
    MemberExpression(memberExpressionPath) {
      if (t.isIdentifier(memberExpressionPath.node.property)) {
        const name = memberExpressionPath.node.property.name;
        if (validMethods.includes(name) && memberExpressionPath.parentPath.isCallExpression()) {
          callExpressionPaths[name] = memberExpressionPath.parentPath;
        }
      }
    }
  });
  if (callExpressionPaths.validator) {
    const innerInputExpression = callExpressionPaths.validator.node.arguments[0];
    if (!innerInputExpression) {
      throw new Error(
        "createServerFn().validator() must be called with a validator!"
      );
    }
    if (opts.env === "client" && !shouldValidateClient && t.isMemberExpression(callExpressionPaths.validator.node.callee)) {
      callExpressionPaths.validator.replaceWith(
        callExpressionPaths.validator.node.callee.object
      );
    }
  }
  const handlerFnPath = (_a = callExpressionPaths.handler) == null ? void 0 : _a.get(
    "arguments.0"
  );
  if (!callExpressionPaths.handler || !handlerFnPath.node) {
    throw codeFrameError(
      opts.code,
      path.node.callee.loc,
      `createServerFn must be called with a "handler" property!`
    );
  }
  const handlerFn = handlerFnPath.node;
  removeUseServerDirective(handlerFnPath);
  handlerFnPath.replaceWith(
    t.arrowFunctionExpression(
      [t.identifier("opts")],
      t.blockStatement(
        // Everything in here is server-only, since the client
        // will strip out anything in the 'use server' directive.
        [
          t.returnStatement(
            t.callExpression(
              t.identifier(`${existingVariableName}.__executeServer`),
              [t.identifier("opts")]
            )
          )
        ],
        [t.directive(t.directiveLiteral("use server"))]
      )
    )
  );
  if (opts.env === "server") {
    callExpressionPaths.handler.node.arguments.push(handlerFn);
  }
}
function removeUseServerDirective(path) {
  path.traverse({
    Directive(path2) {
      if (path2.node.value.value === "use server") {
        path2.remove();
      }
    }
  });
}
function handleCreateMiddlewareCallExpression(path, opts) {
  var _a;
  const rootCallExpression = getRootCallExpression(path);
  if (debug)
    console.info(
      "Handling createMiddleware call expression:",
      rootCallExpression.toString()
    );
  const callExpressionPaths = {
    middleware: null,
    validator: null,
    client: null,
    server: null
  };
  const validMethods = Object.keys(callExpressionPaths);
  rootCallExpression.traverse({
    MemberExpression(memberExpressionPath) {
      if (t.isIdentifier(memberExpressionPath.node.property)) {
        const name = memberExpressionPath.node.property.name;
        if (validMethods.includes(name) && memberExpressionPath.parentPath.isCallExpression()) {
          callExpressionPaths[name] = memberExpressionPath.parentPath;
        }
      }
    }
  });
  if (callExpressionPaths.validator) {
    const innerInputExpression = callExpressionPaths.validator.node.arguments[0];
    if (!innerInputExpression) {
      throw new Error(
        "createMiddleware().validator() must be called with a validator!"
      );
    }
    if (opts.env === "client") {
      if (t.isMemberExpression(callExpressionPaths.validator.node.callee)) {
        callExpressionPaths.validator.replaceWith(
          callExpressionPaths.validator.node.callee.object
        );
      }
    }
  }
  const useFnPath = (_a = callExpressionPaths.server) == null ? void 0 : _a.get(
    "arguments.0"
  );
  if (!callExpressionPaths.server || !useFnPath.node) {
    throw new Error('createMiddleware must be called with a "use" property!');
  }
  if (opts.env === "client") {
    if (t.isMemberExpression(callExpressionPaths.server.node.callee)) {
      callExpressionPaths.server.replaceWith(
        callExpressionPaths.server.node.callee.object
      );
    }
  }
}
function handleServerOnlyCallExpression(path, opts) {
  if (debug)
    console.info("Handling serverOnly call expression:", path.toString());
  if (opts.env === "server") {
    return;
  }
  path.replaceWith(
    t.arrowFunctionExpression(
      [],
      t.blockStatement([
        t.expressionStatement(
          t.callExpression(t.identifier("invariant"), [
            t.booleanLiteral(false),
            t.stringLiteral(
              "serverOnly() functions can only be called on the server!"
            )
          ])
        )
      ])
    )
  );
}
function getRootCallExpression(path) {
  let rootCallExpression = path;
  while (rootCallExpression.parentPath.isMemberExpression()) {
    const parent = rootCallExpression.parentPath;
    if (parent.parentPath.isCallExpression()) {
      rootCallExpression = parent.parentPath;
    }
  }
  return rootCallExpression;
}
function codeFrameError(code, loc, message) {
  const frame = codeFrameColumns(
    code,
    {
      start: loc.start,
      end: loc.end
    },
    {
      highlightCode: true,
      message
    }
  );
  return new Error(frame);
}
export {
  compileEliminateDeadCode,
  compileStartOutput
};
//# sourceMappingURL=compilers.js.map
